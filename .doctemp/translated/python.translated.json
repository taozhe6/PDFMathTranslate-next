{
  "source_file": "/Users/pppppop/Documents/PDFMathTranslate-next/docs/en/advanced/API/python.md",
  "source_lang": "en",
  "outputs": [
    {
      "chunk_id": "chunk_F076772C",
      "chunk_type": "blockquote",
      "original_content": "> [!NOTE]\n> This documentation may contain AI-generated content. While we strive for accuracy, there might be inaccuracies. Please report any issues via:\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - Community contribution (PRs welcome!)\n",
      "start_line_no": 1,
      "translations": {
        "zh_TW": "> [!NOTE]\n> 本文檔可能包含 AI 生成的內容。雖然我們力求準確，但仍可能存在不準確之處。請通過以下方式報告任何問題：\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - 社區貢獻（歡迎提交 PR！）\n",
        "zh": "> [!NOTE]\n> 本文档可能包含 AI 生成内容。虽然我们力求准确，但仍可能存在不准确之处。请通过以下方式报告任何问题：\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - 社区贡献（欢迎提交 PR！）\n",
        "de": "> [!NOTE]\n> Diese Dokumentation kann KI-generierte Inhalte enthalten. Obwohl wir auf Genauigkeit achten, kann es zu Ungenauigkeiten kommen. Bitte melden Sie etwaige Probleme über:\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - Gemeinschaftsbeiträge (PRs sind willkommen!)\n",
        "es": "> [!NOTE]\n> Esta documentación puede contener contenido generado por IA. Aunque nos esforzamos por la precisión, pueden existir inexactitudes. Por favor, reporte cualquier problema a través de:\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - Contribución de la comunidad (¡PRs son bienvenidas!)\n",
        "pt": "> [!NOTE]\n> Esta documentação pode conter conteúdo gerado por IA. Embora nos esforcemos pela precisão, podem ocorrer imprecisões. Por favor, relate quaisquer problemas através de:\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - Contribuição da comunidade (PRs são bem-vindos!)\n",
        "fr": "> [!NOTE]\n> Cette documentation peut contenir du contenu généré par l'IA. Bien que nous nous efforcions d'être précis, il peut y avoir des inexactitudes. Veuillez signaler tout problème via :\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - Contribution de la communauté (les PR sont les bienvenues !)\n",
        "it": "> [!NOTE]\n> Questa documentazione potrebbe contenere contenuti generati dall'IA. Sebbene ci impegniamo per l'accuratezza, potrebbero esserci delle imprecisioni. Si prega di segnalare eventuali problemi tramite:\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - Contributo della comunità (PR sono benvenuti!)\n",
        "ru": "> [!NOTE]\n> Эта документация может содержать контент, созданный искусственным интеллектом. Хотя мы стремимся к точности, могут быть неточности. Пожалуйста, сообщайте о любых проблемах через:\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - Вклад сообщества (PR приветствуются!)\n",
        "ko": "> [!NOTE]\n> 이 문서에는 AI 생성 콘텐츠가 포함될 수 있습니다. 정확성을 위해 노력하고 있지만 부정확한 내용이 있을 수 있습니다. 문제가 발견되면 다음을 통해 신고해 주세요:\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - 커뮤니티 기여 (PR 환영합니다!)\n",
        "ja": "> [!NOTE]\n> このドキュメントには AI 生成コンテンツが含まれている可能性があります。正確性を心がけていますが、不正確な点があるかもしれません。問題があれば以下から報告してください：\n>\n> - [GitHub Issues](https://github.com/PDFMathTranslate-next/PDFMathTranslate-next/issues)\n> - コミュニティ貢献（プルリクエスト歓迎！）\n"
      }
    },
    {
      "chunk_id": "chunk_0B12F3B2",
      "chunk_type": "header",
      "original_content": "## Python API: do_translate_async_stream\n",
      "start_line_no": 7,
      "translations": {
        "de": "## Python API: do_translate_async_stream\n",
        "ko": "## Python API: do_translate_async_stream\n",
        "ru": "## Python API: do_translate_async_stream\n",
        "pt": "## Python API: do_translate_async_stream\n",
        "ja": "## Python API: do_translate_async_stream\n",
        "fr": "## Python API : do_translate_async_stream\n",
        "es": "## Python API: do_translate_async_stream\n",
        "zh_TW": "## Python API: do_translate_async_stream\n",
        "zh": "## Python API: do_translate_async_stream\n",
        "it": "## Python API: do_translate_async_stream\n"
      }
    },
    {
      "chunk_id": "chunk_56087045",
      "chunk_type": "header",
      "original_content": "### Overview",
      "start_line_no": 9,
      "translations": {
        "es": "### Resumen",
        "fr": "### Aperçu",
        "zh_TW": "### 概述",
        "ru": "### Обзор",
        "ja": "### 概要",
        "de": "### Übersicht",
        "ko": "### 개요",
        "pt": "### Visão geral",
        "it": "### Panoramica",
        "zh": "### 概述"
      }
    },
    {
      "chunk_id": "chunk_A750D06F",
      "chunk_type": "list",
      "original_content": "- do_translate_async_stream is the low-level async entrypoint that translates a single PDF and yields a stream of events (progress/error/finish).\n- It is suitable for building your own UI or CLI where you want real-time progress and full control over results.\n- It accepts a validated SettingsModel and a file path and returns an async generator of dict events.\n",
      "start_line_no": 10,
      "translations": {
        "zh": "- do_translate_async_stream 是底层的异步入口点，用于翻译单个 PDF 并生成事件流（进度/错误/完成）。\n- 它适用于构建您自己的 UI 或 CLI，在这些场景中您需要实时进度和对结果的完全控制。\n- 它接受一个经过验证的 SettingsModel 和一个文件路径，并返回一个字典事件的异步生成器。\n",
        "pt": "- do_translate_async_stream é o ponto de entrada assíncrono de baixo nível que traduz um único PDF e produz um fluxo de eventos (progresso/erro/conclusão).\n- É adequado para construir sua própria UI ou CLI onde você deseja progresso em tempo real e controle total sobre os resultados.\n- Ele aceita um SettingsModel validado e um caminho de arquivo e retorna um gerador assíncrono de eventos de dicionário.\n",
        "es": "- do_translate_async_stream es el punto de entrada asíncrono de bajo nivel que traduce un único PDF y produce un flujo de eventos (progreso/error/finalización).\n- Es adecuado para construir tu propia interfaz de usuario o CLI donde desees progreso en tiempo real y control total sobre los resultados.\n- Acepta un SettingsModel validado y una ruta de archivo, y devuelve un generador asíncrono de eventos dict.\n",
        "zh_TW": "- `do_translate_async_stream` 是底層的非同步入口點，用於翻譯單個 `PDF` 並產生一個事件串流（進度/錯誤/完成）。\n- 它適用於構建您自己的 `UI` 或 `CLI`，在這些場景中您需要即時進度並對結果擁有完全控制權。\n- 它接受一個經過驗證的 `SettingsModel` 和一個檔案路徑，並返回一個字典事件的非同步產生器。\n",
        "it": "- do_translate_async_stream è il punto di ingresso asincrono di basso livello che traduce un singolo PDF e restituisce un flusso di eventi (progresso/errore/fine).\n- È adatto per costruire la propria UI o CLI in cui si desidera un progresso in tempo reale e il controllo completo sui risultati.\n- Accetta un SettingsModel validato e un percorso del file e restituisce un generatore asincrono di eventi dict.\n",
        "ko": "- do_translate_async_stream 은 단일 PDF 를 번역하고 이벤트 (진행 상황/오류/완료) 스트림을 생성하는 저수준 비동기 진입점입니다.\n- 실시간 진행 상황과 결과에 대한 완전한 제어를 원하는 사용자 정의 UI 나 CLI 를 구축하는 데 적합합니다.\n- 유효성이 검증된 SettingsModel 과 파일 경로를 수락하고, dict 이벤트의 비동기 생성기를 반환합니다.\n",
        "fr": "- do_translate_async_stream est le point d'entrée asynchrone de bas niveau qui traduit un seul PDF et produit un flux d'événements (progression/erreur/fin).\n- Il est adapté pour construire votre propre interface utilisateur ou CLI où vous souhaitez une progression en temps réel et un contrôle total sur les résultats.\n- Il accepte un SettingsModel validé et un chemin de fichier et retourne un générateur asynchrone d'événements sous forme de dictionnaires.\n",
        "de": "- do_translate_async_stream ist der Low-Level-Async-Einstiegspunkt, der eine einzelne PDF übersetzt und einen Stream von Ereignissen (Fortschritt/Fehler/Fertigstellung) liefert.\n- Es eignet sich zum Erstellen Ihrer eigenen Benutzeroberfläche oder Kommandozeile, bei der Sie Echtzeit-Fortschritt und volle Kontrolle über die Ergebnisse wünschen.\n- Es akzeptiert ein validiertes SettingsModel und einen Dateipfad und gibt einen asynchronen Generator von Dict-Ereignissen zurück.\n",
        "ja": "- do_translate_async_stream は、単一の PDF を翻訳し、イベント（進捗状況／エラー／完了）のストリームを生成する低レベルの非同期エントリーポイントです。\n- リアルタイムの進捗状況と結果の完全な制御を望む独自の UI または CLI を構築する場合に適しています。\n- 検証済みの SettingsModel とファイルパスを受け取り、dict イベントの非同期ジェネレータを返します。\n",
        "ru": "- do_translate_async_stream — это низкоуровневая асинхронная точка входа, которая переводит один PDF-файл и генерирует поток событий (прогресс/ошибка/завершение).\n- Она подходит для создания собственного пользовательского интерфейса или интерфейса командной строки, где требуется прогресс в реальном времени и полный контроль над результатами.\n- Она принимает проверенную SettingsModel и путь к файлу и возвращает асинхронный генератор событий в виде словарей.\n"
      }
    },
    {
      "chunk_id": "chunk_F43C15FB",
      "chunk_type": "header",
      "original_content": "### Signature",
      "start_line_no": 14,
      "translations": {
        "es": "### Firma",
        "ko": "### 서명",
        "it": "### Firma",
        "ja": "### 署名",
        "de": "### Signatur",
        "fr": "### Signature",
        "pt": "### Assinatura",
        "zh_TW": "### 簽名",
        "ru": "### Подпись",
        "zh": "### 签名"
      }
    },
    {
      "chunk_id": "chunk_2BC73677",
      "chunk_type": "list",
      "original_content": "- Import: `from pdf2zh_next.high_level import do_translate_async_stream`\n- Call: `async for event in do_translate_async_stream(settings, file): ...`\n- Parameters:\n  - settings: SettingsModel. Must be valid; the function will call `settings.validate_settings()`.\n  - file: str | pathlib.Path. The single PDF to translate. Must exist.\n",
      "start_line_no": 15,
      "translations": {
        "zh": "- 导入：`from pdf2zh_next.high_level import do_translate_async_stream`\n- 调用：`async for event in do_translate_async_stream(settings, file): ...`\n- 参数：\n  - settings: SettingsModel。必须有效；该函数将调用 `settings.validate_settings()`。\n  - file: str | pathlib.Path。要翻译的单个 PDF 文件。必须存在。\n",
        "de": "- Import: `from pdf2zh_next.high_level import do_translate_async_stream`\n- Aufruf: `async for event in do_translate_async_stream(settings, file): ...`\n- Parameter:\n  - settings: SettingsModel. Muss gültig sein; die Funktion ruft `settings.validate_settings()` auf.\n  - file: str | pathlib.Path. Die einzelne zu übersetzende PDF. Muss existieren.\n",
        "fr": "- Importation : `from pdf2zh_next.high_level import do_translate_async_stream`\n- Appel : `async for event in do_translate_async_stream(settings, file): ...`\n- Paramètres :\n  - settings : SettingsModel. Doit être valide ; la fonction appellera `settings.validate_settings()`.\n  - file : str | pathlib.Path. Le PDF unique à traduire. Doit exister.\n",
        "pt": "- Importar: `from pdf2zh_next.high_level import do_translate_async_stream`\n- Chamar: `async for event in do_translate_async_stream(settings, file): ...`\n- Parâmetros:\n  - settings: SettingsModel. Deve ser válido; a função chamará `settings.validate_settings()`.\n  - file: str | pathlib.Path. O único PDF a ser traduzido. Deve existir.\n",
        "it": "- Import: `from pdf2zh_next.high_level import do_translate_async_stream`\n- Chiamata: `async for event in do_translate_async_stream(settings, file): ...`\n- Parametri:\n  - settings: SettingsModel. Deve essere valido; la funzione chiamerà `settings.validate_settings()`.\n  - file: str | pathlib.Path. Il singolo PDF da tradurre. Deve esistere.\n",
        "ko": "- Import: `from pdf2zh_next.high_level import do_translate_async_stream`\n- Call: `async for event in do_translate_async_stream(settings, file): ...`\n- Parameters:\n  - settings: SettingsModel. 유효해야 합니다; 함수는 `settings.validate_settings()` 를 호출합니다.\n  - file: str | pathlib.Path. 번역할 단일 PDF 파일입니다. 존재해야 합니다.\n",
        "zh_TW": "- 導入：`from pdf2zh_next.high_level import do_translate_async_stream`\n- 呼叫：`async for event in do_translate_async_stream(settings, file): ...`\n- 參數：\n  - settings: SettingsModel。必須是有效的；該函數將呼叫 `settings.validate_settings()`。\n  - file: str | pathlib.Path。要翻譯的單個 PDF 檔案。必須存在。\n",
        "es": "- Importar: `from pdf2zh_next.high_level import do_translate_async_stream`\n- Llamar: `async for event in do_translate_async_stream(settings, file): ...`\n- Parámetros:\n  - settings: SettingsModel. Debe ser válido; la función llamará a `settings.validate_settings()`.\n  - file: str | pathlib.Path. El único PDF a traducir. Debe existir.\n",
        "ru": "- Импорт: `from pdf2zh_next.high_level import do_translate_async_stream`\n- Вызов: `async for event in do_translate_async_stream(settings, file): ...`\n- Параметры:\n  - settings: SettingsModel. Должен быть валидным; функция вызовет `settings.validate_settings()`.\n  - file: str | pathlib.Path. Единичный PDF-файл для перевода. Должен существовать.\n",
        "ja": "- インポート：`from pdf2zh_next.high_level import do_translate_async_stream`\n- 呼び出し：`async for event in do_translate_async_stream(settings, file): ...`\n- パラメータ:\n  - settings: SettingsModel。有効である必要があります。関数は `settings.validate_settings()` を呼び出します。\n  - file: str | pathlib.Path。翻訳する単一の PDF ファイル。存在する必要があります。\n"
      }
    },
    {
      "chunk_id": "chunk_F0CF2344",
      "chunk_type": "paragraph",
      "original_content": "Note:\n",
      "start_line_no": 21,
      "translations": {
        "pt": "Observação:\n",
        "zh": "注意：\n",
        "zh_TW": "注意：\n",
        "es": "Nota:\n",
        "fr": "NOTE\n",
        "ru": "Примечание:\n",
        "ja": "注記：\n",
        "it": "NOTE\n",
        "ko": "참고:\n",
        "de": "Hinweis:\n"
      }
    },
    {
      "chunk_id": "chunk_083FB11D",
      "chunk_type": "list",
      "original_content": "- `settings.basic.input_files` is ignored by this function; only the given `file` is translated.\n- If `settings.basic.debug` is True, translation runs in the main process; otherwise it runs in a subprocess. Event schema is identical for both.\n",
      "start_line_no": 23,
      "translations": {
        "zh": "- `settings.basic.input_files` 被此函数忽略；仅翻译给定的 `file`。\n- 如果 `settings.basic.debug` 为 True，翻译在主进程中运行；否则在子进程中运行。两种情况下的事件模式是相同的。\n",
        "zh_TW": "- `settings.basic.input_files` 在此函數中被忽略；僅翻譯給定的 `file`。\n- 如果 `settings.basic.debug` 為 True，翻譯在主進程中運行；否則在子進程中運行。兩種情況的事件模式是相同的。\n",
        "ru": "- `settings.basic.input_files` игнорируется этой функцией; переводится только указанный `file`.\n- Если `settings.basic.debug` имеет значение True, перевод выполняется в основном процессе; в противном случае он выполняется в подпроцессе. Схема событий идентична в обоих случаях.\n",
        "de": "- `settings.basic.input_files` wird von dieser Funktion ignoriert; nur die angegebene `file` wird übersetzt.\n- Wenn `settings.basic.debug` True ist, läuft die Übersetzung im Hauptprozess; andernfalls läuft sie in einem Unterprozess. Das Ereignisschema ist für beide identisch.\n",
        "pt": "- `settings.basic.input_files` é ignorado por esta função; apenas o `file` fornecido é traduzido.\n- Se `settings.basic.debug` for True, a tradução é executada no processo principal; caso contrário, é executada em um subprocesso. O esquema de eventos é idêntico para ambos.\n",
        "es": "- `settings.basic.input_files` es ignorado por esta función; solo se traduce el `file` proporcionado.\n- Si `settings.basic.debug` es True, la traducción se ejecuta en el proceso principal; de lo contrario, se ejecuta en un subproceso. El esquema de eventos es idéntico en ambos casos.\n",
        "it": "- `settings.basic.input_files` viene ignorato da questa funzione; viene tradotto solo il `file` specificato.\n- Se `settings.basic.debug` è True, la traduzione viene eseguita nel processo principale; altrimenti viene eseguita in un sottoprocesso. Lo schema degli eventi è identico in entrambi i casi.\n",
        "ko": "- `settings.basic.input_files` 는 이 함수에서 무시됩니다; 주어진 `file` 만 번역됩니다.\n- `settings.basic.debug` 가 True 인 경우, 번역은 메인 프로세스에서 실행됩니다; 그렇지 않으면 하위 프로세스에서 실행됩니다. 두 경우 모두 이벤트 스키마는 동일합니다.\n",
        "fr": "- `settings.basic.input_files` est ignoré par cette fonction ; seul le `file` donné est traduit.\n- Si `settings.basic.debug` est True, la traduction s'exécute dans le processus principal ; sinon, elle s'exécute dans un sous-processus. Le schéma d'événements est identique dans les deux cas.\n",
        "ja": "- `settings.basic.input_files` はこの関数では無視され、指定された `file` のみが翻訳されます。\n- `settings.basic.debug` が True の場合、翻訳はメインプロセスで実行されます。それ以外の場合はサブプロセスで実行されます。どちらの場合もイベントスキーマは同一です。\n"
      }
    },
    {
      "chunk_id": "chunk_EB0CE4AC",
      "chunk_type": "header",
      "original_content": "### Event Stream Contract",
      "start_line_no": 26,
      "translations": {
        "zh_TW": "### 事件串流合約",
        "zh": "### 事件流契约",
        "es": "### Contrato de flujo de eventos",
        "ko": "### 이벤트 스트림 계약",
        "ja": "### イベントストリーム契約",
        "pt": "### Contrato de Fluxo de Eventos",
        "de": "### Event-Stream-Vertrag",
        "ru": "### Контракт потока событий",
        "it": "### Contratto del flusso di eventi",
        "fr": "### Contrat de flux d'événements"
      }
    },
    {
      "chunk_id": "chunk_3036F1F2",
      "chunk_type": "paragraph",
      "original_content": "The async generator yields JSON-like dict events with the following types:\n",
      "start_line_no": 27,
      "translations": {
        "zh": "异步生成器会产生以下类型的类 JSON 字典事件：\n",
        "pt": "O gerador assíncrono produz eventos de dicionário semelhantes a JSON com os seguintes tipos:\n",
        "ru": "Асинхронный генератор возвращает события в виде словарей, похожих на JSON, со следующими типами:\n",
        "es": "El generador asíncrono produce eventos de tipo dict similares a JSON con los siguientes tipos:\n",
        "de": "Der asynchrone Generator liefert JSON-ähnliche Dict-Ereignisse mit den folgenden Typen:\n",
        "zh_TW": "非同步產生器會產生以下類型的 JSON 類字典事件：\n",
        "it": "Il generatore asincrono produce eventi di tipo dict simili a JSON con i seguenti tipi:\n",
        "fr": "Le générateur asynchrone produit des événements de type dict similaires à JSON avec les types suivants :\n",
        "ko": "비동기 생성자는 다음과 같은 유형의 JSON 형식 dict 이벤트를 생성합니다:\n",
        "ja": "非同期ジェネレータは以下のタイプの JSON ライクな辞書イベントを生成します：\n"
      }
    },
    {
      "chunk_id": "chunk_675B6F86",
      "chunk_type": "list",
      "original_content": "- Stage summary event: `stage_summary` (optional, may appear first)\n  - Fields\n    - `type`: \"stage_summary\"\n    - `stages`: list of objects `{ \"name\": str, \"percent\": float }` describing the estimated work distribution\n    - `part_index`: may be 0 for this summary event\n    - `total_parts`: total number of parts (>= 1)\n\n- Progress events: `progress_start`, `progress_update`, `progress_end`\n  - Common fields\n    - `type`: one of the above\n    - `stage`: human-readable stage name (e.g., \"Parse PDF and Create Intermediate Representation\", \"Translate Paragraphs\", \"Save PDF\")\n    - `stage_progress`: float in [0, 100] indicating progress within the current stage\n    - `overall_progress`: float in [0, 100] indicating overall progress\n    - `part_index`: current part index (typically 1-based for progress events)\n    - `total_parts`: total number of parts (>= 1). Large documents may be split automatically.\n    - `stage_current`: current step within the stage\n    - `stage_total`: total steps within the stage\n\n- Finish event: `finish`\n  - Fields\n    - `type`: \"finish\"\n    - `translate_result`: an **object** providing final outputs (NOTE: not a dictionary, but a class instance)\n      - `original_pdf_path`: Path to the input PDF\n      - `mono_pdf_path`: Path to the monolingual translated PDF (or None)\n      - `dual_pdf_path`: Path to the bilingual translated PDF (or None)\n      - `no_watermark_mono_pdf_path`: Path to monolingual output without watermark (if produced), otherwise None\n      - `no_watermark_dual_pdf_path`: Path to bilingual output without watermark (if produced), otherwise None\n      - `auto_extracted_glossary_path`: Path to auto-extracted glossary CSV (or None)\n      - `total_seconds`: elapsed seconds (float)\n      - `peak_memory_usage`: approximate peak memory usage during translation (float; implementation-dependent units)\n\n- Error event: `error`\n  - Fields\n    - `type`: \"error\"\n    - `error`: human-readable error message\n    - `error_type`: one of `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError`, etc.\n    - `details`: optional details (e.g., original error or traceback)\n",
      "start_line_no": 29,
      "translations": {
        "zh": "- 阶段摘要事件：`stage_summary`（可选，可能首先出现）\n  - 字段\n    - `type`：\"stage_summary\"\n    - `stages`：对象列表 `{ \"name\": str, \"percent\": float }`，描述估计的工作分布\n    - `part_index`：对于此摘要事件可能为 0\n    - `total_parts`：总部分数（>= 1）\n\n- 进度事件：`progress_start`、`progress_update`、`progress_end`\n  - 公共字段\n    - `type`：上述之一\n    - `stage`：人类可读的阶段名称（例如，\"解析 PDF 并创建中间表示\"、\"翻译段落\"、\"保存 PDF\"）\n    - `stage_progress`：[0, 100] 范围内的浮点数，指示当前阶段内的进度\n    - `overall_progress`：[0, 100] 范围内的浮点数，指示总体进度\n    - `part_index`：当前部分索引（对于进度事件通常从 1 开始）\n    - `total_parts`：总部分数（>= 1）。大型文档可能会自动拆分。\n    - `stage_current`：阶段内的当前步骤\n    - `stage_total`：阶段内的总步骤数\n\n- 完成事件：`finish`\n  - 字段\n    - `type`：\"finish\"\n    - `translate_result`：一个提供最终输出的**对象**（注意：不是字典，而是类实例）\n      - `original_pdf_path`：输入 PDF 的路径\n      - `mono_pdf_path`：单语翻译 PDF 的路径（或 None）\n      - `dual_pdf_path`：双语翻译 PDF 的路径（或 None）\n      - `no_watermark_mono_pdf_path`：无水印单语输出的路径（如果已生成），否则为 None\n      - `no_watermark_dual_pdf_path`：无水印双语输出的路径（如果已生成），否则为 None\n      - `auto_extracted_glossary_path`：自动提取的术语表 CSV 的路径（或 None）\n      - `total_seconds`：经过的秒数（浮点数）\n      - `peak_memory_usage`：翻译过程中的近似峰值内存使用量（浮点数；具体单位取决于实现）\n\n- 错误事件：`error`\n  - 字段\n    - `type`：\"error\"\n    - `error`：人类可读的错误消息\n    - `error_type`：`BabeldocError`、`SubprocessError`、`IPCError`、`SubprocessCrashError` 等之一\n    - `details`：可选的详细信息（例如，原始错误或回溯）\n",
        "zh_TW": "- 階段摘要事件：`stage_summary`（可選，可能最先出現）\n  - 欄位\n    - `type`：\"stage_summary\"\n    - `stages`：物件列表 `{ \"name\": str, \"percent\": float }`，描述估計的工作分配\n    - `part_index`：對於此摘要事件可能為 0\n    - `total_parts`：總部分數（>= 1）\n\n- 進度事件：`progress_start`、`progress_update`、`progress_end`\n  - 通用欄位\n    - `type`：上述之一\n    - `stage`：人類可讀的階段名稱（例如：\"解析 PDF 並建立中間表示\"、\"翻譯段落\"、\"儲存 PDF\"）\n    - `stage_progress`：[0, 100] 內的浮點數，表示當前階段的進度\n    - `overall_progress`：[0, 100] 內的浮點數，表示整體進度\n    - `part_index`：當前部分索引（對於進度事件通常基於 1）\n    - `total_parts`：總部分數（>= 1）。大型文件可能會自動分割。\n    - `stage_current`：階段內的當前步驟\n    - `stage_total`：階段內的總步驟數\n\n- 完成事件：`finish`\n  - 欄位\n    - `type`：\"finish\"\n    - `translate_result`：一個提供最終輸出的**物件**（注意：不是字典，而是類別實例）\n      - `original_pdf_path`：輸入 PDF 的路徑\n      - `mono_pdf_path`：單語翻譯 PDF 的路徑（或 None）\n      - `dual_pdf_path`：雙語翻譯 PDF 的路徑（或 None）\n      - `no_watermark_mono_pdf_path`：無浮水印的單語輸出路徑（如果已產生），否則為 None\n      - `no_watermark_dual_pdf_path`：無浮水印的雙語輸出路徑（如果已產生），否則為 None\n      - `auto_extracted_glossary_path`：自動擷取的術語表 CSV 路徑（或 None）\n      - `total_seconds`：經過的秒數（浮點數）\n      - `peak_memory_usage`：翻譯期間的近似峰值記憶體使用量（浮點數；實作依賴的單位）\n\n- 錯誤事件：`error`\n  - 欄位\n    - `type`：\"error\"\n    - `error`：人類可讀的錯誤訊息\n    - `error_type`：其中之一為 `BabeldocError`、`SubprocessError`、`IPCError`、`SubprocessCrashError` 等。\n    - `details`：可選的詳細資訊（例如，原始錯誤或追溯資訊）\n",
        "es": "- Evento de resumen de etapa: `stage_summary` (opcional, puede aparecer primero)\n  - Campos\n    - `type`: \"stage_summary\"\n    - `stages`: lista de objetos `{ \"name\": str, \"percent\": float }` que describe la distribución estimada del trabajo\n    - `part_index`: puede ser 0 para este evento de resumen\n    - `total_parts`: número total de partes (>= 1)\n\n- Eventos de progreso: `progress_start`, `progress_update`, `progress_end`\n  - Campos comunes\n    - `type`: uno de los anteriores\n    - `stage`: nombre de la etapa legible por humanos (por ejemplo, \"Analizar PDF y Crear Representación Intermedia\", \"Traducir Párrafos\", \"Guardar PDF\")\n    - `stage_progress`: flotante en [0, 100] que indica el progreso dentro de la etapa actual\n    - `overall_progress`: flotante en [0, 100] que indica el progreso general\n    - `part_index`: índice de la parte actual (típicamente basado en 1 para eventos de progreso)\n    - `total_parts`: número total de partes (>= 1). Los documentos grandes pueden dividirse automáticamente.\n    - `stage_current`: paso actual dentro de la etapa\n    - `stage_total`: pasos totales dentro de la etapa\n\n- Evento de finalización: `finish`\n  - Campos\n    - `type`: \"finish\"\n    - `translate_result`: un **objeto** que proporciona las salidas finales (NOTA: no es un diccionario, sino una instancia de clase)\n      - `original_pdf_path`: Ruta al PDF de entrada\n      - `mono_pdf_path`: Ruta al PDF traducido monolingüe (o None)\n      - `dual_pdf_path`: Ruta al PDF traducido bilingüe (o None)\n      - `no_watermark_mono_pdf_path`: Ruta a la salida monolingüe sin marca de agua (si se produjo), de lo contrario None\n      - `no_watermark_dual_pdf_path`: Ruta a la salida bilingüe sin marca de agua (si se produjo), de lo contrario None\n      - `auto_extracted_glossary_path`: Ruta al glosario CSV extraído automáticamente (o None)\n      - `total_seconds`: segundos transcurridos (flotante)\n      - `peak_memory_usage`: uso máximo aproximado de memoria durante la traducción (flotante; unidades dependientes de la implementación)\n\n- Evento de error: `error`\n  - Campos\n    - `type`: \"error\"\n    - `error`: mensaje de error legible por humanos\n    - `error_type`: uno de `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError`, etc.\n    - `details`: detalles opcionales (por ejemplo, error original o traza de ejecución)\n",
        "ko": "- 단계 요약 이벤트: `stage_summary` (선택 사항, 처음 나타날 수 있음)\n  - 필드\n    - `type`: \"stage_summary\"\n    - `stages`: 예상 작업 분포를 설명하는 객체 `{ \"name\": str, \"percent\": float }`의 목록\n    - `part_index`: 이 요약 이벤트의 경우 0 일 수 있음\n    - `total_parts`: 전체 부분 수 (>= 1)\n\n- 진행 상황 이벤트: `progress_start`, `progress_update`, `progress_end`\n  - 공통 필드\n    - `type`: 위 중 하나\n    - `stage`: 사람이 읽을 수 있는 단계 이름 (예: \"PDF 구문 분석 및 중간 표현 생성\", \"단락 번역\", \"PDF 저장\")\n    - `stage_progress`: 현재 단계 내 진행률을 나타내는 [0, 100] 범위의 float\n    - `overall_progress`: 전체 진행률을 나타내는 [0, 100] 범위의 float\n    - `part_index`: 현재 부분 인덱스 (일반적으로 진행 상황 이벤트의 경우 1 부터 시작)\n    - `total_parts`: 전체 부분 수 (>= 1). 큰 문서는 자동으로 분할될 수 있음.\n    - `stage_current`: 단계 내 현재 단계\n    - `stage_total`: 단계 내 전체 단계 수\n\n- 완료 이벤트: `finish`\n  - 필드\n    - `type`: \"finish\"\n    - `translate_result`: 최종 출력을 제공하는 **객체** (참고: 사전이 아닌 클래스 인스턴스)\n      - `original_pdf_path`: 입력 PDF 경로\n      - `mono_pdf_path`: 단일 언어 번역 PDF 경로 (또는 None)\n      - `dual_pdf_path`: 이중 언어 번역 PDF 경로 (또는 None)\n      - `no_watermark_mono_pdf_path`: 워터마크가 없는 단일 언어 출력 경로 (생성된 경우), 그렇지 않으면 None\n      - `no_watermark_dual_pdf_path`: 워터마크가 없는 이중 언어 출력 경로 (생성된 경우), 그렇지 않으면 None\n      - `auto_extracted_glossary_path`: 자동 추출 용어집 CSV 경로 (또는 None)\n      - `total_seconds`: 경과 시간 (초, float)\n      - `peak_memory_usage`: 번역 중 대략적인 최대 메모리 사용량 (float; 구현에 따른 단위)\n\n- 오류 이벤트: `error`\n  - 필드\n    - `type`: \"error\"\n    - `error`: 사람이 읽을 수 있는 오류 메시지\n    - `error_type`: `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError` 등 중 하나\n    - `details`: 선택적 세부 정보 (예: 원본 오류 또는 트레이스백)\n",
        "it": "- Evento di riepilogo fase: `stage_summary` (opzionale, può apparire per primo)\n  - Campi\n    - `type`: \"stage_summary\"\n    - `stages`: lista di oggetti `{ \"name\": str, \"percent\": float }` che descrivono la distribuzione stimata del lavoro\n    - `part_index`: può essere 0 per questo evento di riepilogo\n    - `total_parts`: numero totale di parti (>= 1)\n\n- Eventi di avanzamento: `progress_start`, `progress_update`, `progress_end`\n  - Campi comuni\n    - `type`: uno dei precedenti\n    - `stage`: nome della fase leggibile dall'uomo (ad es. \"Analizza PDF e Crea Rappresentazione Intermedia\", \"Traduci Paragrafi\", \"Salva PDF\")\n    - `stage_progress`: float in [0, 100] che indica l'avanzamento all'interno della fase corrente\n    - `overall_progress`: float in [0, 100] che indica l'avanzamento complessivo\n    - `part_index`: indice della parte corrente (tipicamente basato su 1 per gli eventi di avanzamento)\n    - `total_parts`: numero totale di parti (>= 1). Documenti di grandi dimensioni possono essere suddivisi automaticamente.\n    - `stage_current`: passo corrente all'interno della fase\n    - `stage_total`: passi totali all'interno della fase\n\n- Evento di completamento: `finish`\n  - Campi\n    - `type`: \"finish\"\n    - `translate_result`: un **oggetto** che fornisce gli output finali (NOTA: non un dizionario, ma un'istanza di classe)\n      - `original_pdf_path`: Percorso del PDF di input\n      - `mono_pdf_path`: Percorso del PDF tradotto monolingue (o None)\n      - `dual_pdf_path`: Percorso del PDF tradotto bilingue (o None)\n      - `no_watermark_mono_pdf_path`: Percorso dell'output monolingue senza filigrana (se prodotto), altrimenti None\n      - `no_watermark_dual_pdf_path`: Percorso dell'output bilingue senza filigrana (se prodotto), altrimenti None\n      - `auto_extracted_glossary_path`: Percorso del glossario CSV estratto automaticamente (o None)\n      - `total_seconds`: secondi trascorsi (float)\n      - `peak_memory_usage`: utilizzo approssimativo della memoria di picco durante la traduzione (float; unità dipendenti dall'implementazione)\n\n- Evento di errore: `error`\n  - Campi\n    - `type`: \"error\"\n    - `error`: messaggio di errore leggibile dall'uomo\n    - `error_type`: uno tra `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError`, ecc.\n    - `details`: dettagli opzionali (ad es. errore originale o traceback)\n",
        "pt": "- Evento de resumo de estágio: `stage_summary` (opcional, pode aparecer primeiro)\n  - Campos\n    - `type`: \"stage_summary\"\n    - `stages`: lista de objetos `{ \"name\": str, \"percent\": float }` descrevendo a distribuição estimada do trabalho\n    - `part_index`: pode ser 0 para este evento de resumo\n    - `total_parts`: número total de partes (>= 1)\n\n- Eventos de progresso: `progress_start`, `progress_update`, `progress_end`\n  - Campos comuns\n    - `type`: um dos acima\n    - `stage`: nome do estágio legível por humanos (por exemplo, \"Analisar PDF e Criar Representação Intermediária\", \"Traduzir Parágrafos\", \"Salvar PDF\")\n    - `stage_progress`: float em [0, 100] indicando o progresso dentro do estágio atual\n    - `overall_progress`: float em [0, 100] indicando o progresso geral\n    - `part_index`: índice da parte atual (normalmente baseado em 1 para eventos de progresso)\n    - `total_parts`: número total de partes (>= 1). Documentos grandes podem ser divididos automaticamente.\n    - `stage_current`: etapa atual dentro do estágio\n    - `stage_total`: total de etapas dentro do estágio\n\n- Evento de conclusão: `finish`\n  - Campos\n    - `type`: \"finish\"\n    - `translate_result`: um **objeto** fornecendo as saídas finais (NOTA: não um dicionário, mas uma instância de classe)\n      - `original_pdf_path`: Caminho para o PDF de entrada\n      - `mono_pdf_path`: Caminho para o PDF traduzido monolíngue (ou None)\n      - `dual_pdf_path`: Caminho para o PDF traduzido bilíngue (ou None)\n      - `no_watermark_mono_pdf_path`: Caminho para a saída monolíngue sem marca d'água (se produzida), caso contrário None\n      - `no_watermark_dual_pdf_path`: Caminho para a saída bilíngue sem marca d'água (se produzida), caso contrário None\n      - `auto_extracted_glossary_path`: Caminho para o CSV do glossário extraído automaticamente (ou None)\n      - `total_seconds`: segundos decorridos (float)\n      - `peak_memory_usage`: uso aproximado de memória de pico durante a tradução (float; unidades dependentes da implementação)\n\n- Evento de erro: `error`\n  - Campos\n    - `type`: \"error\"\n    - `error`: mensagem de erro legível por humanos\n    - `error_type`: um de `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError`, etc.\n    - `details`: detalhes opcionais (por exemplo, erro original ou traceback)\n",
        "ja": "- ステージ概要イベント：`stage_summary`（オプション、最初に表示される場合があります）\n  - フィールド\n    - `type`: \"stage_summary\"\n    - `stages`: 推定作業配分を記述するオブジェクト `{ \"name\": str, \"percent\": float }` のリスト\n    - `part_index`: この概要イベントでは 0 になる場合があります\n    - `total_parts`: パートの総数（>= 1）\n\n- 進捗イベント：`progress_start`、`progress_update`、`progress_end`\n  - 共通フィールド\n    - `type`: 上記のいずれか\n    - `stage`: 人間が読めるステージ名（例：「PDF の解析と中間表現の作成」、「段落の翻訳」、「PDF の保存」）\n    - `stage_progress`: 現在のステージ内の進捗を示す [0, 100] の浮動小数点数\n    - `overall_progress`: 全体の進捗を示す [0, 100] の浮動小数点数\n    - `part_index`: 現在のパートインデックス（進捗イベントでは通常 1 から始まる）\n    - `total_parts`: パートの総数（>= 1）。大きな文書は自動的に分割される場合があります。\n    - `stage_current`: ステージ内の現在のステップ\n    - `stage_total`: ステージ内の総ステップ数\n\n- 終了イベント：`finish`\n  - フィールド\n    - `type`: \"finish\"\n    - `translate_result`: 最終出力を提供する**オブジェクト**（注：辞書ではなく、クラスインスタンスです）\n      - `original_pdf_path`: 入力 PDF へのパス\n      - `mono_pdf_path`: 単一言語翻訳 PDF へのパス（または None）\n      - `dual_pdf_path`: 二言語翻訳 PDF へのパス（または None）\n      - `no_watermark_mono_pdf_path`: 透かしなしの単一言語出力へのパス（生成された場合）、それ以外は None\n      - `no_watermark_dual_pdf_path`: 透かしなしの二言語出力へのパス（生成された場合）、それ以外は None\n      - `auto_extracted_glossary_path`: 自動抽出された用語集 CSV へのパス（または None）\n      - `total_seconds`: 経過秒数（浮動小数点数）\n      - `peak_memory_usage`: 翻訳中の概算ピークメモリ使用量（浮動小数点数；実装依存の単位）\n\n- エラーイベント：`error`\n  - フィールド\n    - `type`: \"error\"\n    - `error`: 人間が読めるエラーメッセージ\n    - `error_type`: `BabeldocError`、`SubprocessError`、`IPCError`、`SubprocessCrashError` などのいずれか\n    - `details`: オプションの詳細（例：元のエラーまたはトレースバック）\n",
        "ru": "- Событие сводки этапов: `stage_summary` (опционально, может появиться первым)\n  - Поля\n    - `type`: \"stage_summary\"\n    - `stages`: список объектов `{ \"name\": str, \"percent\": float }`, описывающих предполагаемое распределение работы\n    - `part_index`: может быть 0 для этого сводного события\n    - `total_parts`: общее количество частей (>= 1)\n\n- События прогресса: `progress_start`, `progress_update`, `progress_end`\n  - Общие поля\n    - `type`: один из вышеперечисленных\n    - `stage`: читаемое человеком название этапа (например, \"Разбор PDF и создание промежуточного представления\", \"Перевод абзацев\", \"Сохранение PDF\")\n    - `stage_progress`: число с плавающей точкой в [0, 100], указывающее прогресс в текущем этапе\n    - `overall_progress`: число с плавающей точкой в [0, 100], указывающее общий прогресс\n    - `part_index`: индекс текущей части (обычно начинается с 1 для событий прогресса)\n    - `total_parts`: общее количество частей (>= 1). Большие документы могут быть разделены автоматически.\n    - `stage_current`: текущий шаг в рамках этапа\n    - `stage_total`: общее количество шагов в рамках этапа\n\n- Событие завершения: `finish`\n  - Поля\n    - `type`: \"finish\"\n    - `translate_result`: **объект**, предоставляющий финальные результаты (ПРИМЕЧАНИЕ: не словарь, а экземпляр класса)\n      - `original_pdf_path`: Путь к исходному PDF\n      - `mono_pdf_path`: Путь к переведенному одностраничному PDF (или None)\n      - `dual_pdf_path`: Путь к переведенному двуязычному PDF (или None)\n      - `no_watermark_mono_pdf_path`: Путь к одностраничному выводу без водяного знака (если создан), иначе None\n      - `no_watermark_dual_pdf_path`: Путь к двуязычному выводу без водяного знака (если создан), иначе None\n      - `auto_extracted_glossary_path`: Путь к автоматически извлеченному глоссарию CSV (или None)\n      - `total_seconds`: затраченные секунды (число с плавающей точкой)\n      - `peak_memory_usage`: приблизительное пиковое использование памяти во время перевода (число с плавающей точкой; единицы измерения зависят от реализации)\n\n- Событие ошибки: `error`\n  - Поля\n    - `type`: \"error\"\n    - `error`: читаемое человеком сообщение об ошибке\n    - `error_type`: один из `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError` и т.д.\n    - `details`: опциональные детали (например, исходная ошибка или трассировка стека)\n",
        "fr": "- Événement de résumé des étapes : `stage_summary` (optionnel, peut apparaître en premier)\n  - Champs\n    - `type` : \"stage_summary\"\n    - `stages` : liste d'objets `{ \"name\": str, \"percent\": float }` décrivant la répartition estimée du travail\n    - `part_index` : peut être 0 pour cet événement de résumé\n    - `total_parts` : nombre total de parties (>= 1)\n\n- Événements de progression : `progress_start`, `progress_update`, `progress_end`\n  - Champs communs\n    - `type` : l'un des types ci-dessus\n    - `stage` : nom d'étape lisible par un humain (par exemple, \"Analyser le PDF et créer une représentation intermédiaire\", \"Traduire les paragraphes\", \"Enregistrer le PDF\")\n    - `stage_progress` : float dans [0, 100] indiquant la progression dans l'étape actuelle\n    - `overall_progress` : float dans [0, 100] indiquant la progression globale\n    - `part_index` : index de la partie actuelle (généralement basé sur 1 pour les événements de progression)\n    - `total_parts` : nombre total de parties (>= 1). Les documents volumineux peuvent être divisés automatiquement.\n    - `stage_current` : étape actuelle dans la phase\n    - `stage_total` : nombre total d'étapes dans la phase\n\n- Événement de fin : `finish`\n  - Champs\n    - `type` : \"finish\"\n    - `translate_result` : un **objet** fournissant les sorties finales (NOTE : pas un dictionnaire, mais une instance de classe)\n      - `original_pdf_path` : Chemin d'accès au PDF d'entrée\n      - `mono_pdf_path` : Chemin d'accès au PDF traduit monolingue (ou None)\n      - `dual_pdf_path` : Chemin d'accès au PDF traduit bilingue (ou None)\n      - `no_watermark_mono_pdf_path` : Chemin d'accès à la sortie monolingue sans filigrane (si produite), sinon None\n      - `no_watermark_dual_pdf_path` : Chemin d'accès à la sortie bilingue sans filigrane (si produite), sinon None\n      - `auto_extracted_glossary_path` : Chemin d'accès au glossaire CSV extrait automatiquement (ou None)\n      - `total_seconds` : secondes écoulées (float)\n      - `peak_memory_usage` : utilisation maximale approximative de la mémoire pendant la traduction (float ; unités dépendantes de l'implémentation)\n\n- Événement d'erreur : `error`\n  - Champs\n    - `type` : \"error\"\n    - `error` : message d'erreur lisible par un humain\n    - `error_type` : l'un de `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError`, etc.\n    - `details` : détails optionnels (par exemple, erreur originale ou traceback)\n",
        "de": "-   Stufenzusammenfassungsereignis: `stage_summary` (optional, kann zuerst erscheinen)\n    -   Felder\n        -   `type`: \"stage_summary\"\n        -   `stages`: Liste von Objekten `{ \"name\": str, \"percent\": float }`, die die geschätzte Arbeitsverteilung beschreiben\n        -   `part_index`: kann für dieses Zusammenfassungsereignis 0 sein\n        -   `total_parts`: Gesamtzahl der Teile (>= 1)\n\n-   Fortschrittsereignisse: `progress_start`, `progress_update`, `progress_end`\n    -   Gemeinsame Felder\n        -   `type`: einer der oben genannten\n        -   `stage`: menschenlesbarer Stufenname (z. B. \"PDF parsen und Zwischendarstellung erstellen\", \"Absätze übersetzen\", \"PDF speichern\")\n        -   `stage_progress`: Float in [0, 100], der den Fortschritt innerhalb der aktuellen Stufe anzeigt\n        -   `overall_progress`: Float in [0, 100], der den Gesamtfortschritt anzeigt\n        -   `part_index`: aktueller Teilindex (typischerweise 1-basiert für Fortschrittsereignisse)\n        -   `total_parts`: Gesamtzahl der Teile (>= 1). Große Dokumente können automatisch aufgeteilt werden.\n        -   `stage_current`: aktueller Schritt innerhalb der Stufe\n        -   `stage_total`: Gesamtschritte innerhalb der Stufe\n\n-   Abschlussereignis: `finish`\n    -   Felder\n        -   `type`: \"finish\"\n        -   `translate_result`: ein **Objekt**, das die endgültigen Ausgaben bereitstellt (HINWEIS: kein Wörterbuch, sondern eine Klasseninstanz)\n            -   `original_pdf_path`: Pfad zur Eingabe-PDF\n            -   `mono_pdf_path`: Pfad zur einsprachig übersetzten PDF (oder None)\n            -   `dual_pdf_path`: Pfad zur zweisprachig übersetzten PDF (oder None)\n            -   `no_watermark_mono_pdf_path`: Pfad zur einsprachigen Ausgabe ohne Wasserzeichen (falls erstellt), sonst None\n            -   `no_watermark_dual_pdf_path`: Pfad zur zweisprachigen Ausgabe ohne Wasserzeichen (falls erstellt), sonst None\n            -   `auto_extracted_glossary_path`: Pfad zur automatisch extrahierten Glossar-CSV (oder None)\n            -   `total_seconds`: verstrichene Sekunden (Float)\n            -   `peak_memory_usage`: ungefährer Spitzenspeicherverbrauch während der Übersetzung (Float; implementierungsabhängige Einheiten)\n\n-   Fehlerereignis: `error`\n    -   Felder\n        -   `type`: \"error\"\n        -   `error`: menschenlesbare Fehlermeldung\n        -   `error_type`: einer von `BabeldocError`, `SubprocessError`, `IPCError`, `SubprocessCrashError`, etc.\n        -   `details`: optionale Details (z. B. ursprünglicher Fehler oder Traceback)\n"
      }
    },
    {
      "chunk_id": "chunk_F9D8685D",
      "chunk_type": "paragraph",
      "original_content": "Important behavior:",
      "start_line_no": 67,
      "translations": {
        "zh_TW": "重要行為：",
        "zh": "重要行为：",
        "ja": "重要な動作：",
        "ru": "Важное поведение:",
        "fr": "Comportement important :",
        "ko": "중요한 동작:",
        "es": "Comportamiento importante:",
        "it": "Comportamento importante:",
        "de": "Wichtiges Verhalten:",
        "pt": "Comportamento importante:"
      }
    },
    {
      "chunk_id": "chunk_C8ABE7AA",
      "chunk_type": "list",
      "original_content": "- An optional `stage_summary` may be emitted before progress begins.\n- On certain failures, the generator will first yield an `error` event and then raise an exception derived from `TranslationError`. You should both check for error events and be prepared to catch exceptions.\n- `progress_update` events may repeat with identical values; consumers should debounce if necessary.\n- Stop consuming the stream when you receive a `finish` event.\n",
      "start_line_no": 68,
      "translations": {
        "zh": "- 在进度开始之前，可能会发出一个可选的 `stage_summary`。\n- 在某些故障情况下，生成器将首先产生一个 `error` 事件，然后抛出一个派生自 `TranslationError` 的异常。您应该既检查错误事件，又准备好捕获异常。\n- `progress_update` 事件可能会重复出现相同的值；如有必要，消费者应进行去抖处理。\n- 当您收到 `finish` 事件时，请停止消费流。\n",
        "zh_TW": "- 在進度開始之前，可能會發出一個可選的 `stage_summary`。\n- 在某些失敗情況下，生成器將首先產生一個 `error` 事件，然後引發一個源自 `TranslationError` 的異常。您應該同時檢查錯誤事件並準備好捕獲異常。\n- `progress_update` 事件可能會重複出現相同的值；必要時，消費者應進行去抖動處理。\n- 當您收到 `finish` 事件時，請停止消費串流。\n",
        "es": "- Se puede emitir un `stage_summary` opcional antes de que comience el progreso.\n- En ciertos fallos, el generador primero producirá un evento `error` y luego lanzará una excepción derivada de `TranslationError`. Debes verificar tanto los eventos de error como estar preparado para capturar excepciones.\n- Los eventos `progress_update` pueden repetirse con valores idénticos; los consumidores deben aplicar debounce si es necesario.\n- Deja de consumir el flujo cuando recibas un evento `finish`.\n",
        "ru": "- Необязательный `stage_summary` может быть выдан до начала прогресса.\n- При определенных сбоях генератор сначала выдаст событие `error`, а затем вызовет исключение, производное от `TranslationError`. Вам следует как проверять наличие событий ошибок, так и быть готовым перехватывать исключения.\n- События `progress_update` могут повторяться с одинаковыми значениями; потребители должны устранять дребезг, если это необходимо.\n- Прекратите потреблять поток, когда получите событие `finish`.\n",
        "pt": "- Um `stage_summary` opcional pode ser emitido antes do progresso começar.\n- Em certas falhas, o gerador primeiro produzirá um evento `error` e, em seguida, levantará uma exceção derivada de `TranslationError`. Você deve verificar tanto os eventos de erro quanto estar preparado para capturar exceções.\n- Eventos `progress_update` podem se repetir com valores idênticos; os consumidores devem fazer _debounce_ se necessário.\n- Pare de consumir o fluxo quando receber um evento `finish`.\n",
        "ko": "- 선택적으로 `stage_summary` 가 진행률이 시작되기 전에 발생할 수 있습니다.\n- 특정 실패 시, 생성기는 먼저 `error` 이벤트를 yield 한 다음 `TranslationError` 에서 파생된 예외를 발생시킵니다. 오류 이벤트를 확인하고 예외를 catch 할 준비를 모두 해야 합니다.\n- `progress_update` 이벤트는 동일한 값으로 반복될 수 있습니다; 필요하다면 소비자는 디바운싱을 해야 합니다.\n- `finish` 이벤트를 수신하면 스트림 소비를 중지하세요.\n",
        "it": "- Un `stage_summary` opzionale può essere emesso prima che il progresso inizi.\n- In caso di determinati fallimenti, il generatore emetterà prima un evento `error` e poi solleverà un'eccezione derivata da `TranslationError`. Dovresti sia controllare la presenza di eventi di errore che essere pronto a catturare le eccezioni.\n- Gli eventi `progress_update` possono ripetersi con valori identici; i consumatori dovrebbero eseguire il debounce se necessario.\n- Interrompi il consumo del flusso quando ricevi un evento `finish`.\n",
        "fr": "- Un `stage_summary` facultatif peut être émis avant le début de la progression.\n- En cas de certains échecs, le générateur produira d'abord un événement `error`, puis lèvera une exception dérivée de `TranslationError`. Vous devez à la fois vérifier les événements d'erreur et être prêt à intercepter les exceptions.\n- Les événements `progress_update` peuvent se répéter avec des valeurs identiques ; les consommateurs doivent effectuer un anti-rebond si nécessaire.\n- Arrêtez de consommer le flux lorsque vous recevez un événement `finish`.\n",
        "de": "- Ein optionales `stage_summary` kann ausgegeben werden, bevor der Fortschritt beginnt.\n- Bei bestimmten Fehlern wird der Generator zuerst ein `error`-Ereignis liefern und dann eine Ausnahme auslösen, die von `TranslationError` abgeleitet ist. Sie sollten sowohl auf Fehlerereignisse prüfen als auch darauf vorbereitet sein, Ausnahmen abzufangen.\n- `progress_update`-Ereignisse können sich mit identischen Werten wiederholen; Verbraucher sollten bei Bedarf entprellen.\n- Beenden Sie den Verbrauch des Streams, wenn Sie ein `finish`-Ereignis erhalten.\n",
        "ja": "- 進行が開始される前に、オプションの `stage_summary` が出力される場合があります。\n- 特定の障害が発生した場合、ジェネレーターは最初に `error` イベントを yield し、その後 `TranslationError` から派生した例外を発生させます。エラーイベントをチェックするとともに、例外をキャッチする準備も行う必要があります。\n- `progress_update` イベントは同じ値で繰り返される場合があります。必要に応じて、コンシューマー側でデバウンス処理を実施してください。\n- `finish` イベントを受信したら、ストリームの消費を停止してください。\n"
      }
    },
    {
      "chunk_id": "chunk_FB4E5C3D",
      "chunk_type": "header",
      "original_content": "### Minimal Usage Example (Async)",
      "start_line_no": 73,
      "translations": {
        "zh": "### 最小使用示例（异步）",
        "it": "### Esempio di utilizzo minimo (Async)",
        "ja": "### 最小限の使用例（非同期）",
        "ko": "### 최소 사용 예시 (비동기)",
        "de": "### Minimales Verwendungsbeispiel (Async)",
        "ru": "### Минимальный пример использования (Асинхронный)",
        "zh_TW": "### 最小使用範例（非同步）",
        "es": "### Ejemplo de uso mínimo (Asíncrono)",
        "fr": "### Exemple d'utilisation minimale (Asynchrone)",
        "pt": "### Exemplo de Uso Mínimo (Assíncrono)"
      }
    },
    {
      "chunk_id": "chunk_21C5563D",
      "chunk_type": "code_block",
      "original_content": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
      "start_line_no": 74,
      "translations": {
        "zh": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "zh_TW": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "ja": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "ko": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "ru": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "es": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "fr": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "de": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "it": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n",
        "pt": "```python\nimport asyncio\nfrom pathlib import Path\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\n# Assume you already have a valid SettingsModel instance named `settings`\n# and a PDF file path\n\nasync def translate_one(settings, pdf_path: str | Path):\n    try:\n        async for event in do_translate_async_stream(settings, pdf_path):\n            etype = event.get(\"type\")\n\n            if etype == \"stage_summary\":\n                # Optional pre-flight summary of stages\n                stages = event.get(\"stages\", [])\n                print(\"Stage summary:\", \", \".join(f\"{s['name']}:{s['percent']:.2f}\" for s in stages))\n\n            elif etype in {\"progress_start\", \"progress_update\", \"progress_end\"}:\n                stage = event.get(\"stage\")\n                stage_prog = event.get(\"stage_progress\")  # 0..100\n                overall = event.get(\"overall_progress\")  # 0..100\n                part_i = event.get(\"part_index\")\n                part_n = event.get(\"total_parts\")\n                print(f\"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})\")\n\n            elif etype == \"error\":\n                # You will also get a raised exception after this yield\n                print(\"[error]\", event.get(\"error\"), event.get(\"error_type\"))\n\n            elif etype == \"finish\":\n                result = event[\"translate_result\"]\n                print(\"Done in\", getattr(result, \"total_seconds\", None), \"s\")\n                print(\"Mono:\", getattr(result, \"mono_pdf_path\", None))\n                print(\"Dual:\", getattr(result, \"dual_pdf_path\", None))\n                print(\"No-watermark Mono:\", getattr(result, \"no_watermark_mono_pdf_path\", None))\n                print(\"No-watermark Dual:\", getattr(result, \"no_watermark_dual_pdf_path\", None))\n                print(\"Glossary:\", getattr(result, \"auto_extracted_glossary_path\", None))\n                print(\"Peak memory:\", getattr(result, \"peak_memory_usage\", None))\n                break\n\n    except Exception as exc:\n        # Catch exceptions raised by the stream after an error event\n        print(\"Translation failed:\", exc)\n\n# asyncio.run(translate_one(settings, \"/path/to/file.pdf\"))\n```\n"
      }
    },
    {
      "chunk_id": "chunk_D1A58650",
      "chunk_type": "header",
      "original_content": "### Cancellation",
      "start_line_no": 122,
      "translations": {
        "zh": "### 取消",
        "pt": "### Cancelamento",
        "ko": "### 취소",
        "ru": "### Отмена",
        "es": "### Cancelación",
        "de": "### Stornierung",
        "it": "### Annullamento",
        "fr": "### Annulation",
        "zh_TW": "### 取消",
        "ja": "### キャンセル"
      }
    },
    {
      "chunk_id": "chunk_08070A6A",
      "chunk_type": "paragraph",
      "original_content": "You can cancel the task consuming the stream. Cancellation is propagated to the underlying translation process.\n",
      "start_line_no": 123,
      "translations": {
        "zh_TW": "您可以取消消耗串流的任務。取消操作會傳播到底層的翻譯過程。\n",
        "zh": "您可以取消消耗流式传输的任务。取消操作会传播到底层的翻译进程。\n",
        "ru": "Вы можете отменить задачу, потребляющую поток. Отмена распространяется на базовый процесс перевода.\n",
        "fr": "Vous pouvez annuler la tâche consommant le flux. L'annulation est propagée au processus de traduction sous-jacent.\n",
        "it": "Puoi annullare l'attività consumando il flusso. L'annullamento viene propagato al processo di traduzione sottostante.\n",
        "ja": "ストリームを消費するタスクをキャンセルできます。キャンセルは基盤となる翻訳プロセスに伝播されます。\n",
        "ko": "작업을 취소하면 스트림을 소비하는 작업이 취소됩니다. 취소는 기본 번역 프로세스로 전파됩니다.\n",
        "pt": "Você pode cancelar a tarefa consumindo o fluxo. O cancelamento é propagado para o processo de tradução subjacente.\n",
        "es": "Puedes cancelar la tarea consumiendo el flujo. La cancelación se propaga al proceso de traducción subyacente.\n",
        "de": "Sie können die Aufgabe abbrechen, die den Stream verbraucht. Die Stornierung wird an den zugrunde liegenden Übersetzungsprozess weitergegeben.\n"
      }
    },
    {
      "chunk_id": "chunk_0AF5D8DE",
      "chunk_type": "code_block",
      "original_content": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
      "start_line_no": 125,
      "translations": {
        "zh": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "zh_TW": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "ja": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "ko": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "ru": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "es": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "fr": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "de": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "it": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n",
        "pt": "```python\nimport asyncio\nfrom pdf2zh_next.high_level import do_translate_async_stream\n\nasync def cancellable(settings, pdf):\n    task = asyncio.create_task(_consume(settings, pdf))\n    await asyncio.sleep(1.0)  # let it start\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print(\"Cancelled\")\n\nasync def _consume(settings, pdf):\n    async for event in do_translate_async_stream(settings, pdf):\n        if event[\"type\"] == \"finish\":\n            break\n```\n"
      }
    },
    {
      "chunk_id": "chunk_ED7E6B17",
      "chunk_type": "header",
      "original_content": "### Example Event Shapes",
      "start_line_no": 144,
      "translations": {
        "ja": "### イベント形状の例",
        "it": "### Forme di Evento di Esempio",
        "ru": "### Примеры форм событий",
        "zh": "### 示例事件形状",
        "zh_TW": "### 事件形狀示例",
        "pt": "### Formas de Eventos de Exemplo",
        "ko": "### 이벤트 모양 예시",
        "es": "### Formas de eventos de ejemplo",
        "fr": "### Formes d'événements exemples",
        "de": "### Beispielhafte Ereignisformen"
      }
    },
    {
      "chunk_id": "chunk_6F13A489",
      "chunk_type": "paragraph",
      "original_content": "Stage summary event (example):",
      "start_line_no": 145,
      "translations": {
        "zh": "阶段摘要事件（示例）：",
        "ja": "ステージサマリーイベント（例）：",
        "zh_TW": "Stage summary event (example):",
        "pt": "Resumo do estágio (exemplo):",
        "ru": "Сводное событие этапа (пример):",
        "es": "Evento de resumen de etapa (ejemplo):",
        "it": "Riepilogo dello stage evento (esempio):",
        "fr": "Résumé d'étape (exemple) :",
        "ko": "단계 요약 이벤트 (예시):",
        "de": "Stadiumszusammenfassungsereignis (Beispiel):"
      }
    },
    {
      "chunk_id": "chunk_A8D3C870",
      "chunk_type": "code_block",
      "original_content": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
      "start_line_no": 146,
      "translations": {
        "zh": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "zh_TW": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "ja": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "ko": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "ru": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "es": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "fr": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "de": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "it": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n",
        "pt": "```json\n{\n  \"type\": \"stage_summary\",\n  \"stages\": [\n    {\"name\": \"Parse PDF and Create Intermediate Representation\", \"percent\": 0.1086},\n    {\"name\": \"DetectScannedFile\", \"percent\": 0.0188},\n    {\"name\": \"Parse Page Layout\", \"percent\": 0.1079}\n    // ... more stages ...\n  ],\n  \"part_index\": 0,\n  \"total_parts\": 1\n}\n```\n"
      }
    },
    {
      "chunk_id": "chunk_EECBAE94",
      "chunk_type": "paragraph",
      "original_content": "Progress event (example):",
      "start_line_no": 160,
      "translations": {
        "zh": "Progress event (example):",
        "ja": "Progress イベント（例）：",
        "ko": "Progress event (예시):",
        "zh_TW": "進度事件（範例）：",
        "fr": "Événement de progression (exemple) :",
        "it": "Progress event (esempio):",
        "ru": "Событие прогресса (пример):",
        "de": "Progress-Ereignis (Beispiel):",
        "pt": "Progress event (exemplo):",
        "es": "Evento de progreso (ejemplo):"
      }
    },
    {
      "chunk_id": "chunk_37B241CB",
      "chunk_type": "code_block",
      "original_content": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
      "start_line_no": 161,
      "translations": {
        "zh": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "zh_TW": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "ja": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "ko": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "ru": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "es": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "fr": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "de": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "it": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n",
        "pt": "```json\n{\n  \"type\": \"progress_update\",\n  \"stage\": \"Translate Paragraphs\",\n  \"stage_progress\": 2.04,\n  \"stage_current\": 1,\n  \"stage_total\": 49,\n  \"overall_progress\": 53.44,\n  \"part_index\": 1,\n  \"total_parts\": 1\n}\n```\n"
      }
    },
    {
      "chunk_id": "chunk_C6F45B63",
      "chunk_type": "paragraph",
      "original_content": "Finish event (example):",
      "start_line_no": 174,
      "translations": {
        "zh": "完成事件（示例）：",
        "ko": "Finish event (예시):",
        "ru": "Событие завершения (пример):",
        "es": "Evento de finalización (ejemplo):",
        "zh_TW": "完成事件（範例）：",
        "ja": "Finish event (example):",
        "it": "Finish event (esempio):",
        "fr": "Événement de fin (exemple) :",
        "pt": "Finish event (exemplo):",
        "de": "Finish-Ereignis (Beispiel):"
      }
    },
    {
      "chunk_id": "chunk_6A7D099B",
      "chunk_type": "code_block",
      "original_content": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
      "start_line_no": 175,
      "translations": {
        "zh": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "zh_TW": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "ja": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "ko": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "ru": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "es": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "fr": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "de": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "it": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n",
        "pt": "```json\n{\n  \"type\": \"finish\",\n  \"translate_result\": {\n    \"original_pdf_path\": \"pdf2zh_files/<session>/table.pdf\",\n    \"mono_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.mono.pdf\",\n    \"dual_pdf_path\": \"pdf2zh_files/<session>/table.zh-CN.dual.pdf\",\n    \"no_watermark_mono_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf\",\n    \"no_watermark_dual_pdf_path\": \"pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf\",\n    \"auto_extracted_glossary_path\": \"pdf2zh_files/<session>/table.zh-CN.glossary.csv\",\n    \"total_seconds\": 42.83,\n    \"peak_memory_usage\": 4651.55\n  }\n}\n```\n"
      }
    },
    {
      "chunk_id": "chunk_F8F61FC8",
      "chunk_type": "paragraph",
      "original_content": "Error event (example):",
      "start_line_no": 191,
      "translations": {
        "zh": "错误事件（示例）：",
        "zh_TW": "錯誤事件（範例）：",
        "de": "Fehlerereignis (Beispiel):",
        "ko": "Error event (example):",
        "ja": "エラーイベント（例）：",
        "ru": "Событие ошибки (пример):",
        "es": "Evento de error (ejemplo):",
        "it": "Evento di errore (esempio):",
        "pt": "Evento de erro (exemplo):",
        "fr": "Événement d'erreur (exemple) :"
      }
    },
    {
      "chunk_id": "chunk_D4934FF8",
      "chunk_type": "code_block",
      "original_content": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
      "start_line_no": 192,
      "translations": {
        "zh": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "zh_TW": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "ja": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "ko": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "ru": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "es": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "fr": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "de": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "it": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n",
        "pt": "```json\n{\n  \"type\": \"error\",\n  \"error\": \"Babeldoc translation error: <message>\",\n  \"error_type\": \"BabeldocError\",\n  \"details\": \"<optional original error or traceback>\"\n}\n```\n"
      }
    },
    {
      "chunk_id": "chunk_C7DBFA5F",
      "chunk_type": "header",
      "original_content": "### Notes & Best Practices",
      "start_line_no": 201,
      "translations": {
        "ru": "### Примечания и рекомендации",
        "zh": "### 注意事项与最佳实践",
        "zh_TW": "### 注意事項與最佳實踐",
        "ko": "### 참고 사항 및 모범 사례",
        "it": "### Note e migliori pratiche",
        "pt": "### Notas e Melhores Práticas",
        "de": "### Hinweise & Best Practices",
        "es": "### Notas y mejores prácticas",
        "ja": "### 注意点とベストプラクティス",
        "fr": "### Notes & Meilleures pratiques"
      }
    },
    {
      "chunk_id": "chunk_F18B5199",
      "chunk_type": "list",
      "original_content": "- Always handle both error events and exceptions from the generator.\n- Break the loop on `finish` to avoid unnecessary work.\n- Ensure the `file` exists and `settings.validate_settings()` passes before calling.\n- Large documents may be split; use `part_index/total_parts` and `overall_progress` to drive your UI.\n- Debounce `progress_update` if your UI is sensitive to repeated, identical updates.\n- `report_interval` (SettingsModel): controls only the emission rate of `progress_update` events. It does not affect `stage_summary`, `progress_start`, `progress_end`, or `finish`. Default is 0.1s and the minimum allowed is 0.05s. As per the progress monitor logic, when `stage_total <= 3`, updates are not throttled by `report_interval`.\n\n",
      "start_line_no": 202,
      "translations": {
        "zh": "- 始终处理来自生成器的错误事件和异常。\n- 在 `finish` 事件时中断循环，以避免不必要的工作。\n- 在调用前确保 `file` 存在且 `settings.validate_settings()` 通过验证。\n- 大型文档可能会被拆分；使用 `part_index/total_parts` 和 `overall_progress` 来驱动您的用户界面。\n- 如果您的用户界面对重复、相同的更新敏感，请对 `progress_update` 进行防抖处理。\n- `report_interval` (SettingsModel)：仅控制 `progress_update` 事件的发射频率。它不影响 `stage_summary`、`progress_start`、`progress_end` 或 `finish`。默认值为 0.1 秒，允许的最小值为 0.05 秒。根据进度监视器逻辑，当 `stage_total <= 3` 时，更新不受 `report_interval` 的限制。\n\n",
        "zh_TW": "- 始終處理來自生成器的錯誤事件和異常。\n- 在 `finish` 事件時中斷循環，以避免不必要的工作。\n- 在調用前確保 `file` 存在且 `settings.validate_settings()` 通過驗證。\n- 大型文件可能會被拆分；使用 `part_index/total_parts` 和 `overall_progress` 來驅動您的用戶界面。\n- 如果您的用戶界面對重複、相同的更新敏感，請對 `progress_update` 進行防抖處理。\n- `report_interval` (SettingsModel)：僅控制 `progress_update` 事件的發射速率。它不影響 `stage_summary`、`progress_start`、`progress_end` 或 `finish`。默認值為 0.1 秒，允許的最小值為 0.05 秒。根據進度監控邏輯，當 `stage_total <= 3` 時，更新不受 `report_interval` 的限制。\n\n",
        "fr": "- Toujours gérer à la fois les événements d'erreur et les exceptions provenant du générateur.\n- Interrompre la boucle sur `finish` pour éviter un travail inutile.\n- S'assurer que le `file` existe et que `settings.validate_settings()` passe avant d'appeler.\n- Les documents volumineux peuvent être divisés ; utiliser `part_index/total_parts` et `overall_progress` pour piloter votre interface utilisateur.\n- Débouncer `progress_update` si votre interface utilisateur est sensible aux mises à jour répétées et identiques.\n- `report_interval` (SettingsModel) : contrôle uniquement le taux d'émission des événements `progress_update`. Il n'affecte pas `stage_summary`, `progress_start`, `progress_end` ou `finish`. La valeur par défaut est 0,1s et le minimum autorisé est 0,05s. Selon la logique du moniteur de progression, lorsque `stage_total <= 3`, les mises à jour ne sont pas limitées par `report_interval`.\n\n",
        "es": "-   Maneja siempre tanto los eventos de error como las excepciones del generador.\n-   Rompe el bucle en `finish` para evitar trabajo innecesario.\n-   Asegúrate de que el `file` exista y que `settings.validate_settings()` pase antes de llamar.\n-   Los documentos grandes pueden dividirse; usa `part_index/total_parts` y `overall_progress` para impulsar tu interfaz de usuario.\n-   Debounce `progress_update` si tu interfaz de usuario es sensible a actualizaciones repetidas e idénticas.\n-   `report_interval` (SettingsModel): controla solo la tasa de emisión de eventos `progress_update`. No afecta a `stage_summary`, `progress_start`, `progress_end` o `finish`. El valor predeterminado es 0.1s y el mínimo permitido es 0.05s. Según la lógica del monitor de progreso, cuando `stage_total <= 3`, las actualizaciones no se limitan por `report_interval`.\n\n",
        "ja": "- ジェネレーターからのエラーイベントと例外の両方を常に処理してください。\n- 不要な作業を避けるために、`finish` でループを抜けてください。\n- 呼び出す前に、`file` が存在し、`settings.validate_settings()` が通過することを確認してください。\n- 大きな文書は分割される可能性があります。UI を駆動するために `part_index/total_parts` と `overall_progress` を使用してください。\n- UI が繰り返しの同一更新に敏感な場合は、`progress_update` をデバウンスしてください。\n- `report_interval` (SettingsModel): `progress_update` イベントの送出頻度のみを制御します。`stage_summary`、`progress_start`、`progress_end`、または `finish` には影響しません。デフォルトは 0.1 秒で、最小許容値は 0.05 秒です。進捗モニターのロジックに従い、`stage_total <= 3` の場合、更新は `report_interval` によって調整されません。\n\n",
        "pt": "- Sempre trate tanto os eventos de erro quanto as exceções do gerador.\n- Interrompa o loop em `finish` para evitar trabalho desnecessário.\n- Certifique-se de que o `file` existe e `settings.validate_settings()` passa antes de chamar.\n- Documentos grandes podem ser divididos; use `part_index/total_parts` e `overall_progress` para orientar sua interface do usuário.\n- Debounce `progress_update` se sua interface do usuário for sensível a atualizações repetidas e idênticas.\n- `report_interval` (SettingsModel): controla apenas a taxa de emissão dos eventos `progress_update`. Não afeta `stage_summary`, `progress_start`, `progress_end` ou `finish`. O padrão é 0,1s e o mínimo permitido é 0,05s. Conforme a lógica do monitor de progresso, quando `stage_total <= 3`, as atualizações não são limitadas por `report_interval`.\n\n",
        "ru": "- Всегда обрабатывайте как события ошибок, так и исключения из генератора.\n- Прерывайте цикл при событии `finish`, чтобы избежать ненужной работы.\n- Убедитесь, что `file` существует и `settings.validate_settings()` проходит успешно перед вызовом.\n- Большие документы могут быть разделены; используйте `part_index/total_parts` и `overall_progress` для управления вашим пользовательским интерфейсом.\n- Дебаунсируйте `progress_update`, если ваш пользовательский интерфейс чувствителен к повторяющимся, идентичным обновлениям.\n- `report_interval` (SettingsModel): управляет только частотой генерации событий `progress_update`. Он не влияет на `stage_summary`, `progress_start`, `progress_end` или `finish`. По умолчанию 0.1с, минимально допустимое значение — 0.05с. Согласно логике монитора прогресса, когда `stage_total <= 3`, обновления не регулируются `report_interval`.\n\n",
        "it": "- Gestire sempre sia gli eventi di errore che le eccezioni dal generatore.\n- Interrompere il ciclo su `finish` per evitare lavoro non necessario.\n- Assicurarsi che il `file` esista e che `settings.validate_settings()` passi prima della chiamata.\n- I documenti di grandi dimensioni potrebbero essere divisi; utilizzare `part_index/total_parts` e `overall_progress` per guidare la tua UI.\n- Debounce `progress_update` se la tua UI è sensibile a ripetuti aggiornamenti identici.\n- `report_interval` (SettingsModel): controlla solo la frequenza di emissione degli eventi `progress_update`. Non influisce su `stage_summary`, `progress_start`, `progress_end` o `finish`. Il valore predefinito è 0.1s e il minimo consentito è 0.05s. Come da logica del monitor di avanzamento, quando `stage_total <= 3`, gli aggiornamenti non sono limitati da `report_interval`.\n\n",
        "ko": "- 항상 생성기에서 발생하는 오류 이벤트와 예외를 모두 처리하십시오.\n- 불필요한 작업을 피하기 위해 `finish` 이벤트에서 루프를 중단하십시오.\n- 호출하기 전에 `file` 이 존재하고 `settings.validate_settings()` 가 통과하는지 확인하십시오.\n- 대형 문서는 분할될 수 있습니다. `part_index/total_parts` 와 `overall_progress` 를 사용하여 UI 를 구동하십시오.\n- UI 가 반복적이고 동일한 업데이트에 민감한 경우 `progress_update` 이벤트를 디바운스하십시오.\n- `report_interval` (SettingsModel): `progress_update` 이벤트의 발생 빈도만 제어합니다. `stage_summary`, `progress_start`, `progress_end` 또는 `finish` 에는 영향을 미치지 않습니다. 기본값은 0.1 초이며 허용되는 최소값은 0.05 초입니다. 진행률 모니터 로직에 따라, `stage_total <= 3`일 때 업데이트는 `report_interval` 에 의해 제한되지 않습니다.\n\n",
        "de": "-   Sowohl Fehlerereignisse als auch Ausnahmen vom Generator müssen immer behandelt werden.\n-   Unterbrechen Sie die Schleife bei `finish`, um unnötige Arbeit zu vermeiden.\n-   Stellen Sie sicher, dass die `file` existiert und `settings.validate_settings()` erfolgreich ist, bevor Sie die Funktion aufrufen.\n-   Große Dokumente können aufgeteilt werden; verwenden Sie `part_index/total_parts` und `overall_progress`, um Ihre Benutzeroberfläche zu steuern.\n-   Entprellen Sie `progress_update`, wenn Ihre Benutzeroberfläche empfindlich auf wiederholte, identische Aktualisierungen reagiert.\n-   `report_interval` (SettingsModel): Steuert nur die Ausgaberate von `progress_update`-Ereignissen. Es beeinflusst nicht `stage_summary`, `progress_start`, `progress_end` oder `finish`. Der Standardwert ist 0,1s und das zulässige Minimum ist 0,05s. Gemäß der Fortschrittsmonitor-Logik werden bei `stage_total <= 3` Aktualisierungen nicht durch `report_interval` gedrosselt.\n\n"
      }
    }
  ]
}