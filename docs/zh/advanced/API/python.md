>
> For more details, see our [Community](https://pdf2zh-next.com/community/COMMUNITY.html) and [FAQ](https://pdf2zh-next.com/community/FAQ.html) pages.

---

### OUTPUT LANGUAGE

zh

---

### TRANSLATION

> [!NOTE]
> 本文档可能包含 AI 生成的内容。虽然我们力求准确，但仍可能存在不准确之处。请通过以下方式报告任何问题：
>
> - [GitHub Issues](https://github.com/PDFMathTranslate/PDFMathTranslate-next/issues)
> - 社区贡献（欢迎提交 PR！）
>
> 更多详情，请参阅我们的 [社区](https://pdf2zh-next.com/community/COMMUNITY.html) 和 [常见问题](https://pdf2zh-next.com/community/FAQ.html) 页面。
- ### Supported Languages: The following languages are supported by pdf2zh. You can use the language code to specify the source or target language.

| Language | Code | Notes |
|----------|------|-------|
| English | `en` | - |
| Simplified Chinese | `zh` | - |
| Traditional Chinese | `zh-Hant` | - |
| Japanese | `ja` | - |
| Korean | `ko` | - |
| French | `fr` | - |
| German | `de` | - |
| Spanish | `es` | - |
| Italian | `it` | - |
| Portuguese | `pt` | - |
| Russian | `ru` | - |
| Arabic | `ar` | - |
| Hindi | `hi` | - |
| Bengali | `bn` | - |
| Turkish | `tr` | - |
| Vietnamese | `vi` | - |
| Thai | `th` | - |
| Dutch | `nl` | - |
| Polish | `pl` | - |
| Ukrainian | `uk` | - |
| Greek | `el` | - |
| Czech | `cs` | - |
| Swedish | `sv` | - |
| Danish | `da` | - |
| Finnish | `fi` | - |
| Norwegian | `no` | - |
| Hungarian | `hu` | - |
| Romanian | `ro` | - |
| Bulgarian | `bg` | - |
| Croatian | `hr` | - |
| Slovak | `sk` | - |
| Slovenian | `sl` | - |
| Lithuanian | `lt` | - |
| Latvian | `lv` | - |
| Estonian | `et` | - |
| Maltese | `mt` | - |
| Irish | `ga` | - |
| Welsh | `cy` | - |
| Basque | `eu` | - |
| Catalan | `ca` | - |
| Galician | `gl` | - |
| Icelandic | `is` | - |
| Albanian | `sq` | - |
| Serbian | `sr` | - |
| Macedonian | `mk` | - |
| Bosnian | `bs` | - |
| Montenegrin | `cnr` | - |
| Belarusian | `be` | - |
| Armenian | `hy` | - |
| Georgian | `ka` | - |
| Azerbaijani | `az` | - |
| Kazakh | `kk` | - |
| Uzbek | `uz` | - |
| Turkmen | `tk` | - |
| Kyrgyz | `ky` | - |
| Tajik | `tg` | - |
| Persian | `fa` | - |
| Pashto | `ps` | - |
| Kurdish | `ku` | - |
| Hebrew | `he` | - |
| Yiddish | `yi` | - |
| Amharic | `am` | - |
| Tigrinya | `ti` | - |
| Oromo | `om` | - |
| Somali | `so` | - |
| Swahili | `sw` | - |
| Hausa | `ha` | - |
| Yoruba | `yo` | - |
| Igbo | `ig` | - |
| Zulu | `zu` | - |
| Afrikaans | `af` | - |
| Malay | `ms` | - |
| Indonesian | `id` | - |
| Filipino | `tl` | - |
| Maori | `mi` | - |
| Hawaiian | `haw` | - |
| Samoan | `sm` | - |
| Tongan | `to` | - |
| Fijian | `fj` | - |
| Malayalam | `ml` | - |
| Tamil | `ta` | - |
| Telugu | `te` | - |
| Kannada | `kn` | - |
| Marathi | `mr` | - |
| Gujarati | `gu` | - |
| Punjabi | `pa` | - |
| Nepali | `ne` | - |
| Sinhala | `si` | - |
| Burmese | `my` | - |
| Khmer | `km` | - |
| Lao | `lo` | - |
| Mongolian | `mn` | - |
| Tibetan | `bo` | - |
| Uyghur | `ug` | - |
| Zhuang | `za` | - |
| Other languages | - | Please refer to the translator service documentation for supported languages. |

---

### TRANSLATION RESULT

### 支持的语言

pdf2zh 支持以下语言。您可以使用语言代码指定源语言或目标语言。

| 语言 | 代码 | 备注 |
|------|------|------|
| 英语 | `en` | - |
| 简体中文 | `zh` | - |
| 繁体中文 | `zh-Hant` | - |
| 日语 | `ja` | - |
| 韩语 | `ko` | - |
| 法语 | `fr` | - |
| 德语 | `de` | - |
| 西班牙语 | `es` | - |
| 意大利语 | `it` | - |
| 葡萄牙语 | `pt` | - |
| 俄语 | `ru` | - |
| 阿拉伯语 | `ar` | - |
| 印地语 | `hi` | - |
| 孟加拉语 | `bn` | - |
| 土耳其语 | `tr` | - |
| 越南语 | `vi` | - |
| 泰语 | `th` | - |
| 荷兰语 | `nl` | - |
| 波兰语 | `pl` | - |
| 乌克兰语 | `uk` | - |
| 希腊语 | `el` | - |
| 捷克语 | `cs` | - |
| 瑞典语 | `sv` | - |
| 丹麦语 | `da` | - |
| 芬兰语 | `fi` | - |
| 挪威语 | `no` | - |
| 匈牙利语 | `hu` | - |
| 罗马尼亚语 | `ro` | - |
| 保加利亚语 | `bg` | - |
| 克罗地亚语 | `hr` | - |
| 斯洛伐克语 | `sk` | - |
| 斯洛文尼亚语 | `sl` | - |
| 立陶宛语 | `lt` | - |
| 拉脱维亚语 | `lv` | - |
| 爱沙尼亚语 | `et` | - |
| 马耳他语 | `mt` | - |
| 爱尔兰语 | `ga` | - |
| 威尔士语 | `cy` | - |
| 巴斯克语 | `eu` | - |
| 加泰罗尼亚语 | `ca` | - |
| 加利西亚语 | `gl` | - |
| 冰岛语 | `is` | - |
| 阿尔巴尼亚语 | `sq` | - |
| 塞尔维亚语 | `sr` | - |
| 马其顿语 | `mk` | - |
| 波斯尼亚语 | `bs` | - |
| 黑山语 | `cnr` | - |
| 白俄罗斯语 | `be` | - |
| 亚美尼亚语 | `hy` | - |
| 格鲁吉亚语 | `ka` | - |
| 阿塞拜疆语 | `az` | - |
| 哈萨克语 | `kk` | - |
| 乌兹别克语 | `uz` | - |
| 土库曼语 | `tk` | - |
| 吉尔吉斯语 | `ky` | - |
| 塔吉克语 | `tg` | - |
| 波斯语 | `fa` | - |
| 普什图语 | `ps` | - |
| 库尔德语 | `ku` | - |
| 希伯来语 | `he` | - |
| 意第绪语 | `yi` | - |
| 阿姆哈拉语 | `am` | - |
| 提格里尼亚语 | `ti` | - |
| 奥罗莫语 | `om` | - |
| 索马里语 | `so` | - |
| 斯瓦希里语 | `sw` | - |
| 豪萨语 | `ha` | - |
| 约鲁巴语 | `yo` | - |
| 伊博语 | `ig` | - |
| 祖鲁语 | `zu` | - |
| 南非荷兰语 | `af` | - |
| 马来语 | `ms` | - |
| 印尼语 | `id` | - |
| 菲律宾语 | `tl` | - |
| 毛利语 | `mi` | - |
| 夏威夷语 | `haw` | - |
| 萨摩亚语 | `sm` | - |
| 汤加语 | `to` | - |
| 斐济语 | `fj` | - |
| 马拉雅拉姆语 | `ml` | - |
| 泰米尔语 | `ta` | - |
| 泰卢固语 | `te` | - |
| 卡纳达语 | `kn` | - |
| 马拉地语 | `mr` | - |
| 古吉拉特语 | `gu` | - |
| 旁遮普语 | `pa` | - |
| 尼泊尔语 | `ne` | - |
| 僧伽罗语 | `si` | - |
| 缅甸语 | `my` | - |
| 高棉语 | `km` | - |
| 老挝语 | `lo` | - |
| 蒙古语 | `mn` | - |
| 藏语 | `bo` | - |
| 维吾尔语 | `ug` | - |
| 壮语 | `za` | - |
| 其他语言 | - | 请参阅翻译服务文档以了解支持的语言。 |

**Module**: `pdf2zh.api.translate`
**Function**: `do_translate_async_stream`

### Description

This function is used to translate documents asynchronously using a streaming approach, which returns a generator that yields translated segments in real-time. It is suitable for scenarios requiring immediate feedback, such as GUI applications or real-time translation services.

### Parameters

- `file_path` (str): Path to the PDF file to be translated.
- `target_lang` (str, optional): Target language code. Defaults to `"zh"`.
- `source_lang` (str, optional): Source language code. Defaults to `"en"`. If set to `None`, the language will be detected automatically.
- `translator` (str, optional): Translator service to use. Options include `"openai"`, `"aliyun"`, `"siliconflow"`, etc. Defaults to `"openai"`.
- `translator_config` (dict, optional): Configuration for the translator service. Defaults to `None`.
- `doc_config` (dict, optional): Configuration for document processing. Defaults to `None`.
- `output_path` (str, optional): Path to save the translated document. If not provided, the result will not be saved to a file.
- `callback` (callable, optional): Callback function to handle translated segments. It should accept a dictionary with segment information.

### Returns

- `generator`: A generator that yields dictionaries containing translated segments. Each dictionary has the following structure:
  ```python
  {
      "segment_index": int,           # Index of the segment
      "source_text": str,             # Original text of the segment
      "translated_text": str,         # Translated text of the segment
      "status": str,                  # Status of the segment ("pending", "translating", "completed", "error")
      "error": str or None            # Error message if any
  }
  ```

### Example Usage

```python
from pdf2zh.api.translate import do_translate_async_stream

# Translate a document and process segments in real-time
for segment in do_translate_async_stream(
    file_path="document.pdf",
    target_lang="zh",
    translator="openai",
    translator_config={"api_key": "your_api_key"}
):
    print(f"Segment {segment['segment_index']}: {segment['translated_text']}")
    if segment['status'] == "error":
        print(f"Error: {segment['error']}")
```

### Notes

- The function processes the document in segments, allowing for real-time feedback.
- If `output_path` is provided, the translated document will be saved upon completion.
- The `callback` function can be used to handle each segment as it is translated, which is useful for updating UI elements or logging.

---

### OUTPUT LANGUAGE

zh

pdf2zh is a powerful tool for translating `PDF` files. It supports multiple translation services, including OpenAI, DeepSeek, Aliyun, and SiliconFlow, and allows for both online and offline processing.

This guide will help you get started with pdf2zh. We'll cover the installation process and basic usage to get you up and running quickly.

---

### What You'll Need

- A `PDF` file to translate
- An API key for your chosen translation service (if using online services)
- Basic familiarity with the command line

---

### Next Steps

- [Installation](https://pdf2zh-next.com/getting-started/installation.html)
- [Using Command Line](https://pdf2zh-next.com/getting-started/USAGE_cli.html)
- [Using WebUI](https://pdf2zh-next.com/getting-started/USAGE_webui.html)

---

### 概述

pdf2zh 是一个强大的 `PDF` 文件翻译工具。它支持多种翻译服务，包括 OpenAI、DeepSeek、阿里云和硅基流动，并允许在线和离线处理。

本指南将帮助您开始使用 pdf2zh。我们将介绍安装过程和基本用法，以便您快速上手。

---

### 所需准备

- 要翻译的 `PDF` 文件
- 您选择的翻译服务的 API 密钥（如果使用在线服务）
- 对命令行的基本熟悉

---

### 下一步

- [如何安装](https://pdf2zh-next.com/getting-started/installation.html)
- [使用命令行](https://pdf2zh-next.com/getting-started/USAGE_cli.html)
- [使用 WebUI](https://pdf2zh-next.com/getting-started/USAGE_webui.html)
- You can also use the high-level translate_async function which wraps this and returns a simple result.

---

### TRANSLATION RESULT

- do_translate_async_stream 是底层的异步入口点，用于翻译单个 PDF 并产生事件流（进度/错误/完成）。
- 它适用于构建您自己的 UI 或 CLI，您可以在其中获得实时进度并完全控制结果。
- 它接受一个经过验证的 SettingsModel 和一个文件路径，并返回一个字典事件的异步生成器。
- 您也可以使用高级的 translate_async 函数，它包装了此函数并返回一个简单的结果。

The `Signature` class is used to generate a signature for a given string using a secret key. This signature can be used to verify the integrity and authenticity of the string.

#### Constructor

```javascript
new Signature(secretKey: string)
```

Creates a new `Signature` instance.

- `secretKey` (string): The secret key used for generating the signature.

#### Methods

##### `sign(data: string): string`

Generates a signature for the given data string.

- `data` (string): The data string to sign.
- Returns (string): The generated signature.

##### `verify(data: string, signature: string): boolean`

Verifies the signature of the given data string.

- `data` (string): The data string to verify.
- `signature` (string): The signature to verify against.
- Returns (boolean): `true` if the signature is valid, `false` otherwise.

#### Example

```javascript
const signature = new Signature('my-secret-key');
const data = 'Hello, World!';
const sig = signature.sign(data);
console.log(sig); // Outputs the signature

const isValid = signature.verify(data, sig);
console.log(isValid); // Outputs: true
```

---

### ORIGINAL TEXT

### 签名

`Signature` 类用于使用密钥为给定字符串生成签名。此签名可用于验证字符串的完整性和真实性。

#### 构造函数

```javascript
new Signature(secretKey: string)
```

创建一个新的 `Signature` 实例。

- `secretKey` (string): 用于生成签名的密钥。

#### 方法

##### `sign(data: string): string`

为给定的数据字符串生成签名。

- `data` (string): 要签名的数据字符串。
- 返回 (string): 生成的签名。

##### `verify(data: string, signature: string): boolean`

验证给定数据字符串的签名。

- `data` (string): 要验证的数据字符串。
- `signature` (string): 要验证的签名。
- 返回 (boolean): 如果签名有效则为 `true`，否则为 `false`。

#### 示例

```javascript
const signature = new Signature('my-secret-key');
const data = 'Hello, World!';
const sig = signature.sign(data);
console.log(sig); // 输出签名

const isValid = signature.verify(data, sig);
console.log(isValid); // 输出：true
```
- callback: Optional[Callable[[TranslateAsyncEvent], None]] = None. If provided, this callback will be called with each event.
- Returns: AsyncGenerator[TranslateAsyncEvent, None]. Yields events as they occur.

### Event Types

The function yields events of type `TranslateAsyncEvent`, which is a `TypedDict` with the following fields:

- `type`: Literal["progress", "result", "error", "done"]
- `data`: The data associated with the event. The structure depends on the event type.

#### Progress Event

- `type`: "progress"
- `data`: `ProgressData` with fields:
  - `current`: int. The current progress value.
  - `total`: int. The total progress value.
  - `message`: str. A human-readable message describing the current progress.

#### Result Event

- `type`: "result"
- `data`: `ResultData` with fields:
  - `text`: str. The translated text.
  - `page`: int. The page number of the translated text.

#### Error Event

- `type`: "error"
- `data`: `ErrorData` with fields:
  - `message`: str. A human-readable error message.
  - `code`: Optional[str]. An optional error code.

#### Done Event

- `type`: "done"
- `data`: None

### Example Usage

```python
import asyncio
from pdf2zh_next.high_level import do_translate_async_stream
from pdf2zh_next.models import SettingsModel

async def main():
    settings = SettingsModel(
        provider="openai",
        api_key="your_api_key",
        target_language="zh",
    )
    
    async for event in do_translate_async_stream(settings, "document.pdf"):
        if event["type"] == "progress":
            print(f"Progress: {event['data']['current']}/{event['data']['total']} - {event['data']['message']}")
        elif event["type"] == "result":
            print(f"Page {event['data']['page']}: {event['data']['text']}")
        elif event["type"] == "error":
            print(f"Error: {event['data']['message']}")
        elif event["type"] == "done":
            print("Translation complete")

asyncio.run(main())
```

### Notes

- The function processes the document asynchronously, allowing for real-time feedback.
- The `callback` parameter can be used to handle events in a separate function.
- The function validates the settings before starting the translation.

---

### TRANSLATION

- 导入：`from pdf2zh_next.high_level import do_translate_async_stream`
- 调用：`async for event in do_translate_async_stream(settings, file): ...`
- 参数：
  - settings: SettingsModel。必须有效；函数将调用 `settings.validate_settings()`。
  - file: str | pathlib.Path。要翻译的单个 PDF。必须存在。
  - callback: Optional[Callable[[TranslateAsyncEvent], None]] = None。如果提供，此回调函数将在每个事件发生时被调用。
- 返回：AsyncGenerator[TranslateAsyncEvent, None]。在事件发生时生成事件。

### 事件类型

函数生成类型为 `TranslateAsyncEvent` 的事件，这是一个包含以下字段的 `TypedDict`：

- `type`: Literal["progress", "result", "error", "done"]
- `data`: 与事件关联的数据。结构取决于事件类型。

#### 进度事件

- `type`: "progress"
- `data`: `ProgressData`，包含字段：
  - `current`: int。当前进度值。
  - `total`: int。总进度值。
  - `message`: str。描述当前进度的人类可读消息。

#### 结果事件

- `type`: "result"
- `data`: `ResultData`，包含字段：
  - `text`: str。翻译后的文本。
  - `page`: int。翻译文本的页码。

#### 错误事件

- `type`: "error"
- `data`: `ErrorData`，包含字段：
  - `message`: str。人类可读的错误消息。
  - `code`: Optional[str]。可选的错误代码。

#### 完成事件

- `type`: "done"
- `data`: None

### 使用示例

```python
import asyncio
from pdf2zh_next.high_level import do_translate_async_stream
from pdf2zh_next.models import SettingsModel

async def main():
    settings = SettingsModel(
        provider="openai",
        api_key="your_api_key",
        target_language="zh",
    )
    
    async for event in do_translate_async_stream(settings, "document.pdf"):
        if event["type"] == "progress":
            print(f"进度：{event['data']['current']}/{event['data']['total']} - {event['data']['message']}")
        elif event["type"] == "result":
            print(f"第 {event['data']['page']} 页：{event['data']['text']}")
        elif event["type"] == "error":
            print(f"错误：{event['data']['message']}")
        elif event["type"] == "done":
            print("翻译完成")

asyncio.run(main())
```

### 注意

- 该函数异步处理文档，允许实时反馈。
- `callback` 参数可用于在单独的函数中处理事件。
- 函数在开始翻译前会验证设置。

This is a simple example. In practice, you may want to add more error handling and logging.

For more advanced usage, see the [Advanced Guide](https://pdf2zh.com/advanced).

---

### TRANSLATION RESULT

注意：这是一个简单示例。在实际应用中，您可能需要添加更多错误处理和日志记录。

有关更高级的用法，请参见 [高级指南](https://pdf2zh.com/advanced)。
- The `settings` object is passed to the subprocess if used. It must be JSON-serializable.
- The `callback` is called for each event. Events are documented in [Event Stream Contract](https://pdf2zh-next.com/advanced/EVENT_STREAM_CONTRACT.html).
- This function is intended for use in GUI applications.

---

### TRANSLATION

- 此函数会忽略 settings.basic.input_files；仅翻译给定的 `file`。
- 如果 `settings.basic.debug` 为 True，翻译在主进程中运行；否则在子进程中运行。两种情况下的事件模式是相同的。
- 如果使用子进程，`settings` 对象会被传递给子进程。它必须是 JSON 可序列化的。
- 每个事件都会调用 `callback`。事件记录在 [事件流协议](https://pdf2zh-next.com/advanced/EVENT_STREAM_CONTRACT.html) 中。
- 此函数旨在用于 GUI 应用程序。

This document describes the event stream contract that the pdf2zh server uses to communicate with clients.

#### Event Types

The server sends events of the following types:

- `progress`: Indicates the progress of the translation process.
- `result`: Contains the translated text.
- `error`: Indicates an error that occurred during the translation process.
- `done`: Indicates that the translation process has completed.

#### Event Data

Each event is a JSON object with the following fields:

- `type`: The type of the event. One of `progress`, `result`, `error`, or `done`.
- `data`: The data associated with the event. The structure of the data depends on the event type.

##### Progress Event

The `progress` event contains the following data:

- `current`: The current progress value (number).
- `total`: The total progress value (number).
- `message`: A human-readable message describing the current progress (string).

Example:

```json
{
  "type": "progress",
  "data": {
    "current": 50,
    "total": 100,
    "message": "Translating page 5 of 10"
  }
}
```

##### Result Event

The `result` event contains the following data:

- `text`: The translated text (string).
- `page`: The page number of the translated text (number).

Example:

```json
{
  "type": "result",
  "data": {
    "text": "This is the translated text.",
    "page": 5
  }
}
```

##### Error Event

The `error` event contains the following data:

- `message`: A human-readable error message (string).
- `code`: An optional error code (string).

Example:

```json
{
  "type": "error",
  "data": {
    "message": "Failed to translate page 5",
    "code": "TRANSLATION_ERROR"
  }
}
```

##### Done Event

The `done` event contains no data. It indicates that the translation process has completed.

Example:

```json
{
  "type": "done",
  "data": null
}
```

#### Event Stream Format

The server sends events as Server-Sent Events (SSE). Each event is sent as a text message with the following format:

```
event: <event-type>
data: <json-data>
```

Where `<event-type>` is the type of the event (e.g., `progress`, `result`, `error`, `done`), and `<json-data>` is the JSON string of the event data.

Example:

```
event: progress
data: {"current": 50, "total": 100, "message": "Translating page 5 of 10"}
```

#### Client Implementation

Clients should listen for events on the event stream and handle them accordingly. The following is an example of how to handle events in JavaScript:

```javascript
const eventSource = new EventSource('/translate/stream');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  switch (data.type) {
    case 'progress':
      // Update progress bar
      console.log(`Progress: ${data.data.current}/${data.data.total} - ${data.data.message}`);
      break;
    case 'result':
      // Append translated text
      console.log(`Page ${data.data.page}: ${data.data.text}`);
      break;
    case 'error':
      // Handle error
      console.error(`Error: ${data.data.message}`);
      break;
    case 'done':
      // Translation complete
      console.log('Translation complete');
      eventSource.close();
      break;
  }
};
```

#### Error Handling

If an error occurs during the translation process, the server will send an `error` event and then close the connection. Clients should handle errors appropriately and close the event stream.

#### Completion

When the translation process completes successfully, the server will send a `done` event and then close the connection. Clients should close the event stream upon receiving the `done` event.

---

### OUTPUT LANGUAGE

zh

---

### TRANSLATION

### 事件流协议

本文档描述了 pdf2zh 服务器与客户端通信所用的事件流协议。

#### 事件类型

服务器发送以下类型的事件：

- `progress`：指示翻译过程的进度。
- `result`：包含翻译后的文本。
- `error`：指示翻译过程中发生的错误。
- `done`：指示翻译过程已完成。

#### 事件数据

每个事件都是一个包含以下字段的 JSON 对象：

- `type`：事件类型。取值为 `progress`、`result`、`error` 或 `done` 之一。
- `data`：与事件关联的数据。数据的结构取决于事件类型。

##### 进度事件

`progress` 事件包含以下数据：

- `current`：当前进度值（数字）。
- `total`：总进度值（数字）。
- `message`：描述当前进度的人类可读消息（字符串）。

示例：

```json
{
  "type": "progress",
  "data": {
    "current": 50,
    "total": 100,
    "message": "正在翻译第 5 页，共 10 页"
  }
}
```

##### 结果事件

`result` 事件包含以下数据：

- `text`：翻译后的文本（字符串）。
- `page`：翻译文本的页码（数字）。

示例：

```json
{
  "type": "result",
  "data": {
    "text": "这是翻译后的文本。",
    "page": 5
  }
}
```

##### 错误事件

`error` 事件包含以下数据：

- `message`：人类可读的错误消息（字符串）。
- `code`：可选的错误代码（字符串）。

示例：

```json
{
  "type": "error",
  "data": {
    "message": "翻译第 5 页失败",
    "code": "TRANSLATION_ERROR"
  }
}
```

##### 完成事件

`done` 事件不包含数据。它指示翻译过程已完成。

示例：

```json
{
  "type": "done",
  "data": null
}
```

#### 事件流格式

服务器以服务器发送事件（SSE）的形式发送事件。每个事件都以文本消息的形式发送，格式如下：

```
event: <事件类型>
data: <json 数据>
```

其中 `<事件类型>` 是事件的类型（例如 `progress`、`result`、`error`、`done`），`<json 数据>` 是事件数据的 JSON 字符串。

示例：

```
event: progress
data: {"current": 50, "total": 100, "message": "正在翻译第 5 页，共 10 页"}
```

#### 客户端实现

客户端应监听事件流上的事件并进行相应处理。以下是在 JavaScript 中处理事件的示例：

```javascript
const eventSource = new EventSource('/translate/stream');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  switch (data.type) {
    case 'progress':
      // 更新进度条
      console.log(`进度：${data.data.current}/${data.data.total} - ${data.data.message}`);
      break;
    case 'result':
      // 追加翻译文本
      console.log(`第 ${data.data.page} 页：${data.data.text}`);
      break;
    case 'error':
      // 处理错误
      console.error(`错误：${data.data.message}`);
      break;
    case 'done':
      // 翻译完成
      console.log('翻译完成');
      eventSource.close();
      break;
  }
};
```

#### 错误处理

如果在翻译过程中发生错误，服务器将发送一个 `error` 事件，然后关闭连接。客户端应适当地处理错误并关闭事件流。

#### 完成

当翻译过程成功完成时，服务器将发送一个 `done` 事件，然后关闭连接。客户端应在收到 `done` 事件后关闭事件流。
- `progress`: Indicates the progress of the translation process.
- `result`: Contains the translated text.
- `error`: Indicates an error that occurred during the translation process.
- `done`: Indicates that the translation process has completed.

Each event is a dictionary with the following structure:
```python
{
    "type": str,           # Event type: "progress", "result", "error", or "done"
    "data": dict | None,   # Event data (structure depends on event type)
}
```

### Progress Event

The `progress` event contains the following data:
```python
{
    "current": int,        # Current progress value
    "total": int,          # Total progress value
    "message": str,        # Human-readable progress message
}
```

### Result Event

The `result` event contains the following data:
```python
{
    "text": str,           # Translated text
    "page": int,           # Page number of the translated text
}
```

### Error Event

The `error` event contains the following data:
```python
{
    "message": str,        # Human-readable error message
    "code": str | None,    # Optional error code
}
```

### Done Event

The `done` event contains no data (`data` is `None`).

### Example Usage

```python
import asyncio
from pdf2zh import Translator

async def main():
    translator = Translator(provider="openai", api_key="your_api_key")
    
    async for event in translator.translate_async("input.pdf", "output.pdf"):
        if event["type"] == "progress":
            print(f"Progress: {event['data']['current']}/{event['data']['total']} - {event['data']['message']}")
        elif event["type"] == "result":
            print(f"Page {event['data']['page']}: {event['data']['text']}")
        elif event["type"] == "error":
            print(f"Error: {event['data']['message']}")
        elif event["type"] == "done":
            print("Translation complete")

asyncio.run(main())
```

---

### OUTPUT LANGUAGE

zh

---

### TRANSLATION

异步生成器会产生类似 JSON 的字典事件，包含以下类型：
- `progress`：指示翻译过程的进度。
- `result`：包含翻译后的文本。
- `error`：指示翻译过程中发生的错误。
- `done`：指示翻译过程已完成。

每个事件都是一个具有以下结构的字典：
```python
{
    "type": str,           # 事件类型："progress"、"result"、"error" 或 "done"
    "data": dict | None,   # 事件数据（结构取决于事件类型）
}
```

### 进度事件

`progress` 事件包含以下数据：
```python
{
    "current": int,        # 当前进度值
    "total": int,          # 总进度值
    "message": str,        # 人类可读的进度消息
}
```

### 结果事件

`result` 事件包含以下数据：
```python
{
    "text": str,           # 翻译后的文本
    "page": int,           # 翻译文本的页码
}
```

### 错误事件

`error` 事件包含以下数据：
```python
{
    "message": str,        # 人类可读的错误消息
    "code": str | None,    # 可选的错误代码
}
```

### 完成事件

`done` 事件不包含数据（`data` 为 `None`）。

### 使用示例

```python
import asyncio
from pdf2zh import Translator

async def main():
    translator = Translator(provider="openai", api_key="your_api_key")
    
    async for event in translator.translate_async("input.pdf", "output.pdf"):
        if event["type"] == "progress":
            print(f"进度：{event['data']['current']}/{event['data']['total']} - {event['data']['message']}")
        elif event["type"] == "result":
            print(f"第 {event['data']['page']} 页：{event['data']['text']}")
        elif event["type"] == "error":
            print(f"错误：{event['data']['message']}")
        elif event["type"] == "done":
            print("翻译完成")

asyncio.run(main())
```
- ### Example Event Shapes: The following examples demonstrate how to use the `EventShape` class to define custom event shapes. Each example includes a brief description and the corresponding code snippet.

#### 1. Rectangle Event Shape

A simple rectangular event shape with a fixed width and height.

```python
import numpy as np
from event_shape import EventShape

# Define a rectangle event shape
class RectangleEventShape(EventShape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def contains(self, x, y):
        return (abs(x) <= self.width / 2) and (abs(y) <= self.height / 2)
    
    def get_area(self):
        return self.width * self.height

# Usage
rect = RectangleEventShape(10, 5)
print(f"Area: {rect.get_area()}")
print(f"Contains (0,0): {rect.contains(0, 0)}")
print(f"Contains (6,3): {rect.contains(6, 3)}")
```

#### 2. Circular Event Shape

A circular event shape with a fixed radius.

```python
import numpy as np
from event_shape import EventShape

# Define a circle event shape
class CircleEventShape(EventShape):
    def __init__(self, radius):
        self.radius = radius
    
    def contains(self, x, y):
        return np.sqrt(x**2 + y**2) <= self.radius
    
    def get_area(self):
        return np.pi * self.radius**2

# Usage
circle = CircleEventShape(5)
print(f"Area: {circle.get_area()}")
print(f"Contains (0,0): {circle.contains(0, 0)}")
print(f"Contains (4,3): {circle.contains(4, 3)}")
```

#### 3. Elliptical Event Shape

An elliptical event shape with major and minor axes.

```python
import numpy as np
from event_shape import EventShape

# Define an ellipse event shape
class EllipseEventShape(EventShape):
    def __init__(self, a, b):
        self.a = a  # semi-major axis
        self.b = b  # semi-minor axis
    
    def contains(self, x, y):
        return (x**2 / self.a**2 + y**2 / self.b**2) <= 1
    
    def get_area(self):
        return np.pi * self.a * self.b

# Usage
ellipse = EllipseEventShape(8, 4)
print(f"Area: {ellipse.get_area()}")
print(f"Contains (0,0): {ellipse.contains(0, 0)}")
print(f"Contains (5,3): {ellipse.contains(5, 3)}")
```

#### 4. Custom Polygon Event Shape

A custom polygon event shape defined by a list of vertices.

```python
import numpy as np
from event_shape import EventShape

# Define a polygon event shape
class PolygonEventShape(EventShape):
    def __init__(self, vertices):
        self.vertices = np.array(vertices)
- ### Notes & Best Practices: - **Use `--model` to select a translation model.** The default model is `gpt-4o-mini`; however, if you have access to `gpt-4o`, it is recommended to use it for better quality. You can also use other models, such as `gemini-1.5-pro`, `claude-3-5-sonnet`, or `deepseek-chat` (for Chinese translations). For more information, see [Supported Languages](https://pdf2zh-next.com/advanced/SUPPORTED_LANGUAGES.html).

- **Use `--source-language and --target-language` to specify the language.** The default is to automatically detect the source language and translate to `zh` (Simplified Chinese). You can also translate to other languages, such as `en` (English), `ja` (Japanese), `ko` (Korean), etc. For more information, see [Language Code](https://pdf2zh-next.com/advanced/LANGUAGE_CODE.html).

- **Use `--service` to select a translation service.** The default service is `openai`; you can also use `gemini`, `claude`, `deepseek`, `azure`, `aliyun`, or `siliconflow`. For more information, see [Documentation of Translation Services](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html).

- **Use `--api-key` to provide your API key.** You can also set the API key via the environment variable `OPENAI_API_KEY`, `GEMINI_API_KEY`, etc. For more information, see [Documentation of Translation Services](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html).

- **Use `--output` to specify the output file path.** The default is to output to the same directory as the input file with the suffix `_translated` added.

- **Use `--page-range` to specify the page range to translate.** For example, `--page-range 1-5,10,15-20` will translate pages 1 to 5, 10, and 15 to 20.

- **Use `--batch` to process multiple files.** For example, `--batch *.pdf` will translate all PDF files in the current directory.

- **Use `--threads` to set the number of concurrent threads.** The default is the number of CPU cores. Increasing the number of threads can speed up processing, but may also increase API usage.

- **Use `--dry-run` to simulate the translation process without actually calling the API.** This is useful for checking the number of pages and estimated cost.

- **Use `--cost-limit` to set a cost limit.** The translation will stop if the estimated cost exceeds this limit.

- **Use `--no-cache` to disable caching.** By default, translated pages are cached to avoid retranslating the same content. Use this option to force retranslation.

- **Use `--cache-dir` to specify the cache directory.** The default is `./.pdf2zh_cache`.

- **Use `--log-level` to set the log level.** The default is `INFO`. You can set it to `DEBUG` for more detailed logs.

- **Use `--config` to specify a configuration file.** You can save commonly used options in a configuration file and load them with this option.

- **Use `--help` to view all available options.**

---

### TRANSLATED TEXT

### 注意事项与最佳实践

- **使用 `--model` 选择翻译模型。** 默认模型是 `gpt-4o-mini`；但是，如果您可以使用 `gpt-4o`，推荐使用它以获得更好的质量。您也可以使用其他模型，例如 `gemini-1.5-pro`、`claude-3-5-sonnet` 或 `deepseek-chat`（用于中文翻译）。更多信息请参见 [支持的语言](https://pdf2zh-next.com/advanced/SUPPORTED_LANGUAGES.html)。

- **使用 `--source-language` 和 `--target-language` 指定语言。** 默认会自动检测源语言并翻译为 `zh`（简体中文）。您也可以翻译为其他语言，例如 `en`（英语）、`ja`（日语）、`ko`（韩语）等。更多信息请参见 [语言代码](https://pdf2zh-next.com/advanced/LANGUAGE_CODE.html)。

- **使用 `--service` 选择翻译服务。** 默认服务是 `openai`；您也可以使用 `gemini`、`claude`、`deepseek`、`azure`、`aliyun` 或 `siliconflow`。更多信息请参见 [翻译服务文档](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html)。

- **使用 `--api-key` 提供您的 API 密钥。** 您也可以通过环境变量 `OPENAI_API_KEY`、`GEMINI_API_KEY` 等设置 API 密钥。更多信息请参见 [翻译服务文档](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html)。

- **使用 `--output` 指定输出文件路径。** 默认输出到与输入文件相同的目录，并添加后缀 `_translated`。

- **使用 `--page-range` 指定要翻译的页面范围。** 例如，`--page-range 1-5,10,15-20` 将翻译第 1 到 5 页、第 10 页和第 15 到 20 页。

- **使用 `--batch` 处理多个文件。** 例如，`--batch *.pdf` 将翻译当前目录中的所有 PDF 文件。

- **使用 `--threads` 设置并发线程数。** 默认是 CPU 核心数。增加线程数可以加快处理速度，但也可能增加 API 使用量。

- **使用 `--dry-run` 模拟翻译过程而不实际调用 API。** 这对于检查页面数和估算成本很有用。

- **使用 `--cost-limit` 设置成本限制。** 如果估算成本超过此限制，翻译将停止。

- **使用 `--no-cache` 禁用缓存。** 默认情况下，已翻译的页面会被缓存以避免重复翻译相同内容。使用此选项可强制重新翻译。

- **使用 `--cache-dir` 指定缓存目录。** 默认是 `./.pdf2zh_cache`。

- **使用 `--log-level` 设置日志级别。** 默认是 `INFO`。您可以将其设置为 `DEBUG` 以获取更详细的日志。

- **使用 `--config` 指定配置文件。** 您可以将常用选项保存在配置文件中，并通过此选项加载它们。

- **使用 `--help` 查看所有可用选项。**

---

### BYPASS LIST

- pdf2zh
- PDFMathTranslate
- ---

---

### ORIGINAL TEXT

The async generator yields JSON-like dict events with the following types:
- `progress`: Indicates the progress of the translation process.
- `result`: Contains the translated text.
- `error`: Indicates an error that occurred during the translation process.
- `done`: Indicates that the translation process has completed.

Each event is a dictionary with the following structure:
```python
{
    "type": str,           # Event type: "progress", "result", "error", or "done"
    "data": dict | None,   # Event data (structure depends on event type)
}
```

### Progress Event

The `progress` event contains the following data:
```python
{
    "current": int,        # Current progress value
    "total": int,          # Total progress value
    "message": str,        # Human-readable progress message
}
```

### Result Event

The `result` event contains the following data:
```python
{
    "text": str,           # Translated text
    "page": int,           # Page number of the translated text
}
```

### Error Event

The `error` event contains the following data:
```python
{
    "message": str,        # Human-readable error message
    "code": str | None,    # Optional error code
}
```

### Done Event

The `done` event contains no data (`data` is `None`).

### Example Usage

```python
import asyncio
from pdf2zh import Translator

async def main():
    translator = Translator(provider="openai", api_key="your_api_key")
    
    async for event in translator.translate_async("input.pdf", "output.pdf"):
        if event["type"] == "progress":
            print(f"Progress: {event['data']['current']}/{event['data']['total']} - {event['data']['message']}")
        elif event["type"] == "result":
            print(f"Page {event['data']['page']}: {event['data']['text']}")
        elif event["type"] == "error":
            print(f"Error: {event['data']['message']}")
        elif event["type"] == "done":
            print("Translation complete")

asyncio.run(main())
```

---

### OUTPUT LANGUAGE

zh

---

### TRANSLATION

异步生成器会产生类似 JSON 的字典事件，包含以下类型：
- `progress`：指示翻译过程的进度。
- `result`：包含翻译后的文本。
- `error`：指示翻译过程中发生的错误。
- `done`：指示翻译过程已完成。

每个事件都是一个具有以下结构的字典：
```python
{
    "type": str,           # 事件类型："progress"、"result"、"error" 或 "done"
    "data": dict | None,   # 事件数据（结构取决于事件类型）
}
```

### 进度事件

`progress` 事件包含以下数据：
```python
{
    "current": int,        # 当前进度值
    "total": int,          # 总进度值
    "message": str,        # 人类可读的进度消息
}
```

### 结果事件

`result` 事件包含以下数据：
```python
{
    "text": str,           # 翻译后的文本
    "page": int,           # 翻译文本的页码
}
```

### 错误事件

`error` 事件包含以下数据：
```python
{
    "message": str,        # 人类可读的错误消息
    "code": str | None,    # 可选的错误代码
}
```

### 完成事件

`done` 事件不包含数据（`data` 为 `None`）。

### 使用示例

```python
import asyncio
from pdf2zh import Translator

async def main():
    translator = Translator(provider="openai", api_key="your_api_key")
    
    async for event in translator.translate_async("input.pdf", "output.pdf"):
        if event["type"] == "progress":
            print(f"进度：{event['data']['current']}/{event['data']['total']} - {event['data']['message']}")
        elif event["type"] == "result":
            print(f"第 {event['data']['page']} 页：{event['data']['text']}")
        elif event["type"] == "error":
            print(f"错误：{event['data']['message']}")
        elif event["type"] == "done":
            print("翻译完成")

asyncio.run(main())
```

- `stage`: optional stage name where error occurred

---

### OUTPUT LANGUAGE

zh

---

### TRANSLATION

- 阶段摘要事件：`stage_summary`（可选，可能首先出现）
  - 字段
    - `type`: "stage_summary"
    - `stages`: 对象列表 `{ "name": str, "percent": float }`，描述预估的工作分布
    - `part_index`: 对于此摘要事件可能为 0
    - `total_parts`: 总部分数（>= 1）

- 进度事件：`progress_start`、`progress_update`、`progress_end`
  - 公共字段
    - `type`: 上述类型之一
    - `stage`: 人类可读的阶段名称（例如，“解析 PDF 并创建中间表示”、“翻译段落”、“保存 PDF”）
    - `stage_progress`: [0, 100] 内的浮点数，表示当前阶段内的进度
    - `overall_progress`: [0, 100] 内的浮点数，表示整体进度
    - `part_index`: 当前部分索引（进度事件通常从 1 开始）
    - `total_parts`: 总部分数（>= 1）。大文档可能会自动拆分。
    - `stage_current`: 阶段内的当前步骤
    - `stage_total`: 阶段内的总步骤数

- 完成事件：`finish`
  - 字段
    - `type`: "finish"
    - `translate_result`: 一个提供最终输出的**对象**（注意：不是字典，而是类实例）
      - `original_pdf_path`: 输入 PDF 的路径
      - `mono_pdf_path`: 单语翻译 PDF 的路径（或 None）
      - `dual_pdf_path`: 双语翻译 PDF 的路径（或 None）
      - `no_watermark_mono_pdf_path`: 无水印单语输出的路径（如果生成了），否则为 None
      - `no_watermark_dual_pdf_path`: 无水印双语输出的路径（如果生成了），否则为 None
      - `auto_extracted_glossary_path`: 自动提取的术语表 CSV 的路径（或 None）
      - `total_seconds`: 经过的秒数（浮点数）
      - `peak_memory_usage`: 翻译过程中的近似峰值内存使用量（浮点数；具体单位取决于实现）

- 错误事件：`error`
  - 字段
    - `type`: "error"
    - `error`: 人类可读的错误消息
    - `error_type`: `BabeldocError`、`SubprocessError`、`IPCError`、`SubprocessCrashError` 等之一
    - `details`: 可选的详细信息（例如，原始错误或回溯）
    - `stage`: 错误发生时的可选阶段名称
- ### Introduction: This guide will help you get started with the `pdf2zh` Python package. We'll cover the installation process and basic usage to get you up and running quickly.

---

### What is `pdf2zh`?

`pdf2zh` is a powerful Python library for translating PDF documents. It supports multiple translation services and provides both synchronous and asynchronous interfaces.

Key features include:

- Support for multiple translation providers (OpenAI, Gemini, Claude, etc.)
- Both synchronous and asynchronous APIs
- Flexible configuration options
- Batch processing capabilities
- Caching to avoid redundant translations

---

### Installation

You can install `pdf2zh` using pip:

```bash
pip install pdf2zh
```

For the latest development version, you can install directly from GitHub:

```bash
pip install git+https://github.com/your-username/pdf2zh.git
```

---

### Quick Start

Here's a minimal example to translate a PDF document:

```python
from pdf2zh import SyncTranslator

# Initialize the translator
translator = SyncTranslator(
    provider="openai",
    api_key="your-api-key-here"
)

# Translate a PDF
result = translator.translate(
    input_file="document.pdf",
    output_file="translated_document.pdf",
    target_language="zh"
)

print(f"Translation completed! Output saved to: {result.output_file}")
```

For asynchronous usage:

```python
import asyncio
from pdf2zh import Translator

async def main():
    translator = Translator(
        provider="openai",
        api_key="your-api-key-here"
    )
    
    result = await translator.translate(
        input_file="document.pdf",
        output_file="translated_document.pdf",
        target_language="zh"
    )
    
    print(f"Translation completed! Output saved to: {result.output_file}")

asyncio.run(main())
```

---

### Configuration

You can configure various aspects of the translation process:

```python
from pdf2zh import SyncTranslator

translator = SyncTranslator(
    provider="openai",
    api_key="your-api-key-here",
    model="gpt-4",  # Specify model
    source_language="en",  # Source language (auto-detected if not specified)
    cache_enabled=True,  # Enable caching
    cache_dir="./cache"  # Custom cache directory
)
```

---

### Supported Providers

`pdf2zh` supports multiple translation providers:

- OpenAI (`openai`)
- Google Gemini (`gemini`)
- Anthropic Claude (`claude`)
- DeepSeek (`deepseek`)
- Azure OpenAI (`azure`)
- Aliyun (`aliyun`)
- SiliconFlow (`siliconflow`)

Each provider requires its own API key and may have different configuration options.

---

### Next Steps

- Learn about advanced configuration options
- Explore batch processing capabilities
- Understand error handling and logging
- Check out the API reference for detailed documentation

---

### Need Help?

If you encounter any issues or have questions:

- Check the [FAQ](https://pdf2zh.com/faq)
- Join our [Community](https://pdf2zh.com/community)
- Open an issue on [GitHub](https://github.com/your-username/pdf2zh/issues)

---

### TRANSLATION

### 简介

本指南将帮助您开始使用 `pdf2zh` Python 包。我们将介绍安装过程和基本用法，以便您快速上手。

---

### 什么是 `pdf2zh`？

`pdf2zh` 是一个功能强大的 Python 库，用于翻译 PDF 文档。它支持多种翻译服务，并提供同步和异步接口。

主要功能包括：

- 支持多种翻译提供商（OpenAI、Gemini、Claude 等）
- 同步和异步 API
- 灵活的配置选项
- 批处理能力
- 缓存以避免重复翻译

---

### 安装

您可以使用 pip 安装 `pdf2zh`：

```bash
pip install pdf2zh
```

要安装最新的开发版本，可以直接从 GitHub 安装：

```bash
pip install git+https://github.com/your-username/pdf2zh.git
```

---

### 快速开始

以下是一个翻译 PDF 文档的最小示例：

```python
from pdf2zh import SyncTranslator

# 初始化翻译器
translator = SyncTranslator(
    provider="openai",
    api_key="your-api-key-here"
)

# 翻译 PDF
result = translator.translate(
    input_file="document.pdf",
    output_file="translated_document.pdf",
    target_language="zh"
)

print(f"Translation completed! Output saved to: {result.output_file}")
```

异步使用方式：

```python
import asyncio
from pdf2zh import Translator

async def main():
    translator = Translator(
        provider="openai",
        api_key="your-api-key-here"
    )
    
    result = await translator.translate(
        input_file="document.pdf",
        output_file="translated_document.pdf",
        target_language="zh"
    )
    
    print(f"Translation completed! Output saved to: {result.output_file}")

asyncio.run(main())
```

---

### 配置

您可以配置翻译过程的各个方面：

```python
from pdf2zh import SyncTranslator

translator = SyncTranslator(
    provider="openai",
    api_key="your-api-key-here",
    model="gpt-4",  # 指定模型
    source_language="en",  # 源语言（如果未指定则自动检测）
    cache_enabled=True,  # 启用缓存
    cache_dir="./cache"  # 自定义缓存目录
)
```

---

### 支持的提供商

`pdf2zh` 支持多种翻译提供商：

- OpenAI (`openai`)
- Google Gemini (`gemini`)
- Anthropic Claude (`claude`)
- DeepSeek (`deepseek`)
- Azure OpenAI (`azure`)
- 阿里云 (`aliyun`)
- 硅基流动 (`siliconflow`)

每个提供商都需要自己的 API 密钥，并且可能有不同的配置选项。

---

### 下一步

- 了解高级配置选项
- 探索批处理能力
- 理解错误处理和日志记录
- 查看 API 参考以获取详细文档

---

### 需要帮助？

如果您遇到任何问题或有疑问：

- 查看 [常见问题](https://pdf2zh.com/faq)
- 加入我们的 [社区](https://pdf2zh.com/community)
- 在 [GitHub](https://github.com/your-username/pdf2zh/issues) 上提交问题

If `source_lang` is set to `None`, the function will attempt to detect the language of the document automatically. This is useful when you are unsure of the source language.

---

### TRANSLATION

重要行为：如果 `source_lang` 设置为 `None`，该函数将尝试自动检测文档的语言。当您不确定源语言时，这非常有用。
- The `finish` event will not be emitted if an error occurs.

---

### TRANSLATION

- 在进度开始之前，可能会发出一个可选的 `stage_summary`。
- 在某些失败情况下，生成器将首先产生一个 `error` 事件，然后引发一个派生自 `TranslationError` 的异常。您应该同时检查错误事件并准备捕获异常。
- `progress_update` 事件可能会重复出现相同的值；如有必要，消费者应进行去抖处理。
- 当您收到 `finish` 事件时，停止消费流。
- 如果发生错误，将不会发出 `finish` 事件。

The following is a minimal example of using `pdf2zh` asynchronously:

```python
import asyncio
from pdf2zh import Translator

async def main():
    # Initialize Translator
    translator = Translator(
        provider = "openai", # Choose translation service provider
        api_key = "your_api_key_here", # Your API key
    )
    
    # Translate PDF
    result = await translator.translate(
        input_file = "input.pdf", # Path to the PDF file to be translated
        output_file = "output.pdf", # Path to save the translated PDF
        target_language = "zh", # Target language code (zh for Chinese)
    )
    
    print(f"Translation completed. Output saved to: {result.output_file}")

asyncio.run(main())
```

### Minimal Usage Example (Sync)

If you prefer synchronous code, you can use the sync interface:

```python
from pdf2zh import SyncTranslator

# Initialize Translator
translator = SyncTranslator(
    provider = "openai", # Choose translation service provider
    api_key = "your_api_key_here", # Your API key
)

# Translate PDF
result = translator.translate(
    input_file = "input.pdf", # Path to the PDF file to be translated
    output_file = "output.pdf", # Path to save the translated PDF
    target_language = "zh", # Target language code (zh for Chinese)
)

print(f"Translation completed. Output saved to: {result.output_file}")
```

### Key Parameters

- `provider`: Translation service provider (e.g., "openai", "gemini", "siliconflow", etc.)
- `api_key`: Your API key for the chosen provider
- `input_file`: Path to the input PDF file
- `output_file`: Path to save the translated PDF
- `target_language`: Target language code (e.g., "zh" for Chinese)

---

### TRANSLATION RESULT

### 最小使用示例（异步）

以下是一个异步使用 `pdf2zh` 的最小示例：

```python
import asyncio
from pdf2zh import Translator

async def main():
    # 初始化 Translator
    translator = Translator(
        provider = "openai", # 选择翻译服务提供商
        api_key = "your_api_key_here", # 你的 API 密钥
    )
    
    # 翻译 PDF
    result = await translator.translate(
        input_file = "input.pdf", # 待翻译的 PDF 文件路径
        output_file = "output.pdf", # 保存翻译后 PDF 的路径
        target_language = "zh", # 目标语言代码（zh 表示中文）
    )
    
    print(f"Translation completed. Output saved to: {result.output_file}")

asyncio.run(main())
```

### 最小使用示例（同步）

如果你更喜欢同步代码，可以使用同步接口：

```python
from pdf2zh import SyncTranslator

# 初始化 Translator
translator = SyncTranslator(
    provider = "openai", # 选择翻译服务提供商
    api_key = "your_api_key_here", # 你的 API 密钥
)

# 翻译 PDF
result = translator.translate(
    input_file = "input.pdf", # 待翻译的 PDF 文件路径
    output_file = "output.pdf", # 保存翻译后 PDF 的路径
    target_language = "zh", # 目标语言代码（zh 表示中文）
)

print(f"Translation completed. Output saved to: {result.output_file}")
```

### 关键参数

- `provider`: 翻译服务提供商（例如 "openai"、"gemini"、"siliconflow" 等）
- `api_key`: 你所选提供商的 API 密钥
- `input_file`: 输入 PDF 文件的路径
- `output_file`: 保存翻译后 PDF 的路径
- `target_language`: 目标语言代码（例如 "zh" 表示中文）
```python
import asyncio
from pathlib import Path
from pdf2zh_next.high_level import do_translate_async_stream

# Assume you already have a valid SettingsModel instance named `settings`
# and a PDF file path

async def translate_one(settings, pdf_path: str | Path):
    try:
        async for event in do_translate_async_stream(settings, pdf_path):
            etype = event.get("type")

            if etype == "stage_summary":
                # Optional pre-flight summary of stages
                stages = event.get("stages", [])
                print("Stage summary:", ", ".join(f"{s['name']}:{s['percent']:.2f}" for s in stages))

            elif etype in {"progress_start", "progress_update", "progress_end"}:
                stage = event.get("stage")
                stage_prog = event.get("stage_progress")  # 0..100
                overall = event.get("overall_progress")  # 0..100
                part_i = event.get("part_index")
                part_n = event.get("total_parts")
                print(f"[{etype}] {stage} | stage {stage_prog:.1f}% | overall {overall:.1f}% (part {part_i}/{part_n})")

            elif etype == "error":
                # You will also get a raised exception after this yield
                print("[error]", event.get("error"), event.get("error_type"))

            elif etype == "finish":
                result = event["translate_result"]
                print("Done in", getattr(result, "total_seconds", None), "s")
                print("Mono:", getattr(result, "mono_pdf_path", None))
                print("Dual:", getattr(result, "dual_pdf_path", None))
                print("No-watermark Mono:", getattr(result, "no_watermark_mono_pdf_path", None))
                print("No-watermark Dual:", getattr(result, "no_watermark_dual_pdf_path", None))
                print("Glossary:", getattr(result, "auto_extracted_glossary_path", None))
                print("Peak memory:", getattr(result, "peak_memory_usage", None))
                break

    except Exception as exc:
        # Catch exceptions raised by the stream after an error event
        print("Translation failed:", exc)

# asyncio.run(translate_one(settings, "/path/to/file.pdf"))
```

and Refund Policy

**Last Updated: 2024-09-10**

#### 1. Cancellation Policy

You may cancel your subscription at any time. Upon cancellation, you will continue to have access to the paid features until the end of your current billing period. After that, your account will revert to the free plan.

To cancel your subscription, please follow these steps:

1. Log in to your account.
2. Navigate to the [Billing](https://pdf2zh.com/billing) page.
3. Click on the "Cancel Subscription" button.
4. Follow the on-screen instructions to confirm the cancellation.

#### 2. Refund Policy

We offer refunds under the following circumstances:

- **Technical Issues**: If you experience persistent technical issues that prevent you from using the service, and our support team is unable to resolve them within a reasonable time.
- **Billing Errors**: In case of duplicate charges or other billing errors.

Refund requests must be submitted within 14 days of the charge date. To request a refund, please contact our support team at [support@pdf2zh.com](mailto:support@pdf2zh.com) with the following information:

- Your account email
- The date of the charge
- A detailed description of the issue

Please note that we do not offer refunds for:

- Change of mind or dissatisfaction with the service
- Non-use of the service
- Partial months of service

#### 3. Contact Us

If you have any questions about this Cancellation and Refund Policy, please contact us at [support@pdf2zh.com](mailto:support@pdf2zh.com).

---

### TRANSLATION

### 取消与退款政策

**最后更新：2024-09-10**

#### 1. 取消政策

您可以随时取消您的订阅。取消后，您将继续享有付费功能的使用权限，直至当前计费周期结束。此后，您的账户将恢复为免费计划。

要取消订阅，请按照以下步骤操作：

1. 登录您的账户。
2. 导航至 [Billing](https://pdf2zh.com/billing) 页面。
3. 点击“取消订阅”按钮。
4. 按照屏幕上的指示确认取消。

#### 2. 退款政策

我们在以下情况下提供退款：

- **技术问题**：如果您遇到持续的技术问题导致无法使用服务，且我们的支持团队无法在合理时间内解决。
- **计费错误**：发生重复扣款或其他计费错误时。

退款请求必须在扣款日期后的 14 天内提交。要申请退款，请通过 [support@pdf2zh.com](mailto:support@pdf2zh.com) 联系我们的支持团队，并提供以下信息：

- 您的账户邮箱
- 扣款日期
- 问题的详细描述

请注意，以下情况不予退款：

- 改变主意或对服务不满意
- 未使用服务
- 部分月份的服务

#### 3. 联系我们

如果您对此取消与退款政策有任何疑问，请通过 [support@pdf2zh.com](mailto:support@pdf2zh.com) 联系我们。

---
If you want to cancel the translation, you can call the `cancel()` method on the task.

```python
task = asyncio.create_task(do_translate_async_stream(...))
# ... later ...
task.cancel()
```

---

### TRANSLATION RESULT

您可以取消消耗流的任务。取消操作会传播到底层的翻译过程。
如果您想取消翻译，可以在任务上调用 `cancel()` 方法。

```python
task = asyncio.create_task(do_translate_async_stream(...))
# ... 稍后 ...
task.cancel()
```

```python
import asyncio
from pdf2zh_next.high_level import do_translate_async_stream

async def cancellable(settings, pdf):
    task = asyncio.create_task(_consume(settings, pdf))
    await asyncio.sleep(1.0)  # let it start
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print("Cancelled")

async def _consume(settings, pdf):
    async for event in do_translate_async_stream(settings, pdf):
        if event["type"] == "finish":
            break
```

The following examples demonstrate how to use the `EventShape` class to define custom event shapes. Each example includes a brief description and the corresponding code snippet.

#### 1. Rectangle Event Shape

A simple rectangular event shape with a fixed width and height.

```python
import numpy as np
from event_shape import EventShape

# Define a rectangle event shape
class RectangleEventShape(EventShape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def contains(self, x, y):
        return (abs(x) <= self.width / 2) and (abs(y) <= self.height / 2)
    
    def get_area(self):
        return self.width * self.height

# Usage
rect = RectangleEventShape(10, 5)
print(f"Area: {rect.get_area()}")
print(f"Contains (0,0): {rect.contains(0, 0)}")
print(f"Contains (6,3): {rect.contains(6, 3)}")
```

#### 2. Circular Event Shape

A circular event shape with a fixed radius.

```python
import numpy as np
from event_shape import EventShape

# Define a circle event shape
class CircleEventShape(EventShape):
    def __init__(self, radius):
        self.radius = radius
    
    def contains(self, x, y):
        return np.sqrt(x**2 + y**2) <= self.radius
    
    def get_area(self):
        return np.pi * self.radius**2

# Usage
circle = CircleEventShape(5)
print(f"Area: {circle.get_area()}")
print(f"Contains (0,0): {circle.contains(0, 0)}")
print(f"Contains (4,3): {circle.contains(4, 3)}")
```

#### 3. Elliptical Event Shape

An elliptical event shape with major and minor axes.

```python
import numpy as np
from event_shape import EventShape

# Define an ellipse event shape
class EllipseEventShape(EventShape):
    def __init__(self, a, b):
        self.a = a  # semi-major axis
        self.b = b  # semi-minor axis
    
    def contains(self, x, y):
        return (x**2 / self.a**2 + y**2 / self.b**2) <= 1
    
    def get_area(self):
        return np.pi * self.a * self.b

# Usage
ellipse = EllipseEventShape(8, 4)
print(f"Area: {ellipse.get_area()}")
print(f"Contains (0,0): {ellipse.contains(0, 0)}")
print(f"Contains (5,3): {ellipse.contains(5, 3)}")
```

#### 4. Custom Polygon Event Shape

A custom polygon event shape defined by a list of vertices.

```python
import numpy as np
from event_shape import EventShape

# Define a polygon event shape
class PolygonEventShape(EventShape):
    def __init__(self, vertices):
        self.vertices = np.array(vertices)
json
{
  "type": "stage_summary",
  "data": {
    "stage": "translation",
    "progress": 0.5,
    "message": "Translation completed for 5 out of 10 pages"
  }
}
```

---

### TRANSLATION

阶段摘要事件（示例）：

```json
{
  "type": "stage_summary",
  "data": {
    "stage": "translation",
    "progress": 0.5,
    "message": "Translation completed for 5 out of 10 pages"
  }
}
```json
{
  "type": "stage_summary",
  "stages": [
    {"name": "Parse PDF and Create Intermediate Representation", "percent": 0.1086},
    {"name": "DetectScannedFile", "percent": 0.0188},
    {"name": "Parse Page Layout", "percent": 0.1079}
    // ... more stages ...
  ],
  "part_index": 0,
  "total_parts": 1
}
```

json
{
    "type": "progress",
    "data": {
        "current": 5,
        "total": 10,
        "message": "Translating page 5 of 10"
    }
}
```

Result event (example):

```json
{
    "type": "result",
    "data": {
        "text": "This is the translated text.",
        "page": 5
    }
}
```

Error event (example):

```json
{
    "type": "error",
    "data": {
        "message": "Failed to translate page 5",
        "code": "TRANSLATION_ERROR"
    }
}
```

Done event (example):

```json
{
    "type": "done",
    "data": null
}
```

---

### TRANSLATION

进度事件（示例）：

```json
{
    "type": "progress",
    "data": {
        "current": 5,
        "total": 10,
        "message": "正在翻译第 5 页，共 10 页"
    }
}
```

结果事件（示例）：

```json
{
    "type": "result",
    "data": {
        "text": "这是翻译后的文本。",
        "page": 5
    }
}
```

错误事件（示例）：

```json
{
    "type": "error",
    "data": {
        "message": "翻译第 5 页失败",
        "code": "TRANSLATION_ERROR"
    }
}
```

完成事件（示例）：

```json
{
    "type": "done",
    "data": null
}
```json
{
  "type": "progress_update",
  "stage": "Translate Paragraphs",
  "stage_progress": 2.04,
  "stage_current": 1,
  "stage_total": 49,
  "overall_progress": 53.44,
  "part_index": 1,
  "total_parts": 1
}
```

json
{
  "type": "finish",
  "data": {
    "total_pages": 10,
    "total_tokens": 1500,
    "total_cost": 0.015,
    "output_file": "/path/to/output.pdf"
  }
}
```

---

### TRANSLATION

完成事件（示例）：

```json
{
  "type": "finish",
  "data": {
    "total_pages": 10,
    "total_tokens": 1500,
    "total_cost": 0.015,
    "output_file": "/path/to/output.pdf"
  }
}
```json
{
  "type": "finish",
  "translate_result": {
    "original_pdf_path": "pdf2zh_files/<session>/table.pdf",
    "mono_pdf_path": "pdf2zh_files/<session>/table.zh-CN.mono.pdf",
    "dual_pdf_path": "pdf2zh_files/<session>/table.zh-CN.dual.pdf",
    "no_watermark_mono_pdf_path": "pdf2zh_files/<session>/table.no_watermark.zh-CN.mono.pdf",
    "no_watermark_dual_pdf_path": "pdf2zh_files/<session>/table.no_watermark.zh-CN.dual.pdf",
    "auto_extracted_glossary_path": "pdf2zh_files/<session>/table.zh-CN.glossary.csv",
    "total_seconds": 42.83,
    "peak_memory_usage": 4651.55
  }
}
```

`{"type": "error", "data": {"message": "Failed to translate page 5", "code": "TRANSLATION_ERROR"}}`

---

### TRANSLATION

错误事件（示例）：`{"type": "error", "data": {"message": "Failed to translate page 5", "code": "TRANSLATION_ERROR"}}`
```json
{
  "type": "error",
  "error": "Babeldoc translation error: <message>",
  "error_type": "BabeldocError",
  "details": "<optional original error or traceback>"
}
```

- **Use `--model` to select a translation model.** The default model is `gpt-4o-mini`; however, if you have access to `gpt-4o`, it is recommended to use it for better quality. You can also use other models, such as `gemini-1.5-pro`, `claude-3-5-sonnet`, or `deepseek-chat` (for Chinese translations). For more information, see [Supported Languages](https://pdf2zh-next.com/advanced/SUPPORTED_LANGUAGES.html).

- **Use `--source-language` and `--target-language` to specify the language.** The default is to automatically detect the source language and translate to `zh` (Simplified Chinese). You can also translate to other languages, such as `en` (English), `ja` (Japanese), `ko` (Korean), etc. For more information, see [Language Code](https://pdf2zh-next.com/advanced/LANGUAGE_CODE.html).

- **Use `--service` to select a translation service.** The default service is `openai`; you can also use `gemini`, `claude`, `deepseek`, `azure`, `aliyun`, or `siliconflow`. For more information, see [Documentation of Translation Services](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html).

- **Use `--api-key` to provide your API key.** You can also set the API key via the environment variable `OPENAI_API_KEY`, `GEMINI_API_KEY`, etc. For more information, see [Documentation of Translation Services](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html).

- **Use `--output` to specify the output file path.** The default is to output to the same directory as the input file with the suffix `_translated` added.

- **Use `--page-range` to specify the page range to translate.** For example, `--page-range 1-5,10,15-20` will translate pages 1 to 5, 10, and 15 to 20.

- **Use `--batch` to process multiple files.** For example, `--batch *.pdf` will translate all PDF files in the current directory.

- **Use `--threads` to set the number of concurrent threads.** The default is the number of CPU cores. Increasing the number of threads can speed up processing, but may also increase API usage.

- **Use `--dry-run` to simulate the translation process without actually calling the API.** This is useful for checking the number of pages and estimated cost.

- **Use `--cost-limit` to set a cost limit.** The translation will stop if the estimated cost exceeds this limit.

- **Use `--no-cache` to disable caching.** By default, translated pages are cached to avoid retranslating the same content. Use this option to force retranslation.

- **Use `--cache-dir` to specify the cache directory.** The default is `./.pdf2zh_cache`.

- **Use `--log-level` to set the log level.** The default is `INFO`. You can set it to `DEBUG` for more detailed logs.

- **Use `--config` to specify a configuration file.** You can save commonly used options in a configuration file and load them with this option.

- **Use `--help` to view all available options.**

---

### TRANSLATED TEXT

### 注意事项与最佳实践

- **使用 `--model` 选择翻译模型。** 默认模型是 `gpt-4o-mini`；但是，如果您可以使用 `gpt-4o`，推荐使用它以获得更好的质量。您也可以使用其他模型，例如 `gemini-1.5-pro`、`claude-3-5-sonnet` 或 `deepseek-chat`（用于中文翻译）。更多信息请参见 [支持的语言](https://pdf2zh-next.com/advanced/SUPPORTED_LANGUAGES.html)。

- **使用 `--source-language` 和 `--target-language` 指定语言。** 默认会自动检测源语言并翻译为 `zh`（简体中文）。您也可以翻译为其他语言，例如 `en`（英语）、`ja`（日语）、`ko`（韩语）等。更多信息请参见 [语言代码](https://pdf2zh-next.com/advanced/LANGUAGE_CODE.html)。

- **使用 `--service` 选择翻译服务。** 默认服务是 `openai`；您也可以使用 `gemini`、`claude`、`deepseek`、`azure`、`aliyun` 或 `siliconflow`。更多信息请参见 [翻译服务文档](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html)。

- **使用 `--api-key` 提供您的 API 密钥。** 您也可以通过环境变量 `OPENAI_API_KEY`、`GEMINI_API_KEY` 等设置 API 密钥。更多信息请参见 [翻译服务文档](https://pdf2zh-next.com/advanced/TRANSLATION_SERVICES.html)。

- **使用 `--output` 指定输出文件路径。** 默认输出到与输入文件相同的目录，并添加后缀 `_translated`。

- **使用 `--page-range` 指定要翻译的页面范围。** 例如，`--page-range 1-5,10,15-20` 将翻译第 1 到 5 页、第 10 页和第 15 到 20 页。

- **使用 `--batch` 处理多个文件。** 例如，`--batch *.pdf` 将翻译当前目录中的所有 PDF 文件。

- **使用 `--threads` 设置并发线程数。** 默认是 CPU 核心数。增加线程数可以加快处理速度，但也可能增加 API 使用量。

- **使用 `--dry-run` 模拟翻译过程而不实际调用 API。** 这对于检查页面数和估算成本很有用。

- **使用 `--cost-limit` 设置成本限制。** 如果估算成本超过此限制，翻译将停止。

- **使用 `--no-cache` 禁用缓存。** 默认情况下，已翻译的页面会被缓存以避免重复翻译相同内容。使用此选项可强制重新翻译。

- **使用 `--cache-dir` 指定缓存目录。** 默认是 `./.pdf2zh_cache`。

- **使用 `--log-level` 设置日志级别。** 默认是 `INFO`。您可以将其设置为 `DEBUG` 以获取更详细的日志。

- **使用 `--config` 指定配置文件。** 您可以将常用选项保存在配置文件中，并通过此选项加载它们。

- **使用 `--help` 查看所有可用选项。**
---

### TRANSLATION

- 始终处理生成器中的错误事件和异常。
- 在 `finish` 时中断循环以避免不必要的工作。
- 在调用前确保 `file` 存在且 `settings.validate_settings()` 通过。
- 大型文档可能会被拆分；使用 `part_index/total_parts` 和 `overall_progress` 来驱动您的 UI。
- 如果您的 UI 对重复的相同更新敏感，请对 `progress_update` 进行防抖处理。
- `report_interval`（SettingsModel）：仅控制 `progress_update` 事件的发出频率。它不影响 `stage_summary`、`progress_start`、`progress_end` 或 `finish`。默认值为 0.1 秒，最小允许值为 0.05 秒。根据进度监视器逻辑，当 `stage_total <= 3` 时，更新不受 `report_interval` 的限制。

<div align="right"> 
<h6><small>本页面的部分内容由 GPT 翻译，可能包含错误。</small></h6>